Задание:
Создайте через rabbitmqctl пользователя vasya и выдайте ему права администратора. На проверку пришлите команды, которые использовались, a также результат выполнения команды rabbitmqctl list_users.
Составьте команду rabbitmqctl list_queues, которая выводит для каждой очереди количество persistent и ram сообщений.



****************************************************************************
Решение
****************************************************************************

Ефошкин Максим Вячеславович
ОТПРАВЛЕНО
02.12.2022 10:46
1. Установка
address: 158.160.12.146

Воспользовался инструкциями с официального сайта по установке. 
Там рекомендут скрипт
vi install_rabbitmq.sh
***********************************************************************************************
#!/usr/bin/sh

sudo apt-get install curl gnupg apt-transport-https -y

## Team RabbitMQ's main signing key
curl -1sLf "https://keys.openpgp.org/vks/v1/by-fingerprint/0A9AF2115F4687BD29803A206B73A36E6026DFCA" | sudo gpg --dearmor | sudo tee /usr/share/keyrings/com.rabbitmq.team.gpg > /dev/null
## Launchpad PPA that provides modern Erlang releases
curl -1sLf "https://keyserver.ubuntu.com/pks/lookup?op=get&search=0xf77f1eda57ebb1cc" | sudo gpg --dearmor | sudo tee /usr/share/keyrings/net.launchpad.ppa.rabbitmq.erlang.gpg > /dev/null
## PackageCloud RabbitMQ repository
curl -1sLf "https://packagecloud.io/rabbitmq/rabbitmq-server/gpgkey" | sudo gpg --dearmor | sudo tee /usr/share/keyrings/io.packagecloud.rabbitmq.gpg > /dev/null

## Add apt repositories maintained by Team RabbitMQ
sudo tee /etc/apt/sources.list.d/rabbitmq.list <<EOF
## Provides modern Erlang/OTP releases
##
## "bionic" as distribution name should work for any reasonably recent Ubuntu or Debian release.
## See the release to distribution mapping table in RabbitMQ doc guides to learn more.
deb [signed-by=/usr/share/keyrings/net.launchpad.ppa.rabbitmq.erlang.gpg] http://ppa.launchpad.net/rabbitmq/rabbitmq-erlang/ubuntu bionic main
deb-src [signed-by=/usr/share/keyrings/net.launchpad.ppa.rabbitmq.erlang.gpg] http://ppa.launchpad.net/rabbitmq/rabbitmq-erlang/ubuntu bionic main

## Provides RabbitMQ
##
## "bionic" as distribution name should work for any reasonably recent Ubuntu or Debian release.
## See the release to distribution mapping table in RabbitMQ doc guides to learn more.
deb [signed-by=/usr/share/keyrings/io.packagecloud.rabbitmq.gpg] https://packagecloud.io/rabbitmq/rabbitmq-server/ubuntu/ bionic main
deb-src [signed-by=/usr/share/keyrings/io.packagecloud.rabbitmq.gpg] https://packagecloud.io/rabbitmq/rabbitmq-server/ubuntu/ bionic main
EOF

## Update package indices
sudo apt-get update -y

## Install Erlang packages
sudo apt-get install -y erlang-base \
                        erlang-asn1 erlang-crypto erlang-eldap erlang-ftp erlang-inets \
                        erlang-mnesia erlang-os-mon erlang-parsetools erlang-public-key \
                        erlang-runtime-tools erlang-snmp erlang-ssl \
                        erlang-syntax-tools erlang-tftp erlang-tools erlang-xmerl

## Install rabbitmq-server and its dependencies
sudo apt-get install rabbitmq-server -y --fix-missing
**********************************************************************
chmod +x install_rabbitmq.sh
./install_rabbitmq.sh


Добавляем пользователя
rabbitmqctl add_user vasya secret
Adding user "vasya" ...
Done. Don't forget to grant the user permissions to some virtual hosts! See 'rabbitmqctl help set_permissions' to learn more.

Даем права. 
rabbitmqctl set_permissions  vasya ".*" ".*" ".*"
Setting permissions for user "vasya" in vhost "/" ...

rabbitmqctl authenticate_user vasya secret
Authenticating user "vasya" ...
Success

Добавляем права администратора
root@epdk2iip3lmaf9ctf0qd:/home/yc-user# rabbitmqctl set_user_tags vasya administrator
Setting tags for user "vasya" to [administrator] ...

root@epdk2iip3lmaf9ctf0qd:/home/yc-user# rabbitmqctl list_users
Listing users ...
user	tags
vasya	[administrator]
guest	[administrator]


2. Составьте команду rabbitmqctl list_queues, которая выводит для каждой очереди количество persistent и ram сообщений.
rabbitmqctl list_queues --local message_bytes_persistent memory

Проверяем
Создаем скрипт отправки сообщений
root@epdk2iip3lmaf9ctf0qd:/home/yc-user# vi send.py 
#!/usr/bin/env python
import pika

connection = pika.BlockingConnection(pika.ConnectionParameters('localhost'))
channel = connection.channel()
channel.queue_declare(queue='hello')
channel.basic_publish(exchange='',
                      routing_key='hello',
                      body='Hello World!')
print(" [x] Sent 'Hello World!'")
connection.close()

root@epdk2iip3lmaf9ctf0qd:/home/yc-user# cat receive.py 
#!/usr/bin/env python
import pika

connection = pika.BlockingConnection(pika.ConnectionParameters('localhost'))
channel = connection.channel()
channel.queue_declare(queue='hello')
def callback(ch, method, properties, body):
    print(" [x] Received %r" % body)
channel.basic_consume(queue='hello',
                      auto_ack=True,
                      on_message_callback=callback)
print(' [*] Waiting for messages. To exit press CTRL+C')
channel.start_consuming()
if __name__ == '__main__':
    try:
        main()
    except KeyboardInterrupt:
        print('Interrupted')
        try:
            sys.exit(0)
        except SystemExit:
            os._exit(0)

Проверяем
root@epdk2iip3lmaf9ctf0qd:/home/yc-user# python3 send.py 
 [x] Sent 'Hello World!'

python3 receive.py 
 [*] Waiting for messages. To exit press CTRL+C
 [x] Received b'Hello World!'

Проверка
root@epdk2iip3lmaf9ctf0qd:/home/yc-user# rabbitmqctl list_queues --local message_bytes_persistent memory
Timeout: 60.0 seconds ...
Listing queues for vhost / ...
message_bytes_persistent	memory
0	34808


ОТВЕТ КУРАТОРА
Алексей Кузнецов (@Hystrix)
ВЫПОЛНЕНО 5
03.12.2022 07:12
Добрый день!

Отличные знание темы и обстоятельный разбор задания, замечаний и вопросов нет!




*****************************************************************************
Теория
*****************************************************************************


LNXA-10 01: Applications. RabbitMQ
Описание:
RabbitMQ - это брокер сообщений, написанный на языке Erlang. Чаще всего его используют именно в связке с протоколом AMQP (Advanced Message Queuing Protocol), хотя он и поддерживает другие (STOMP, MQTT). Основная идея данного протокола состоит в том, что отдельные приложения могут обмениваться информацией через брокер. Как правило, RabbitMQ используется как шина для обмена между микросервисами, через которую передаются не очень большие сообщения, содержащие сигнальные данные.

Одним из примеров использования RabbitMQ является отправка SMS сообщений в виде фоновых задач. RabbitMQ можно сравнить с почтовым отделением, основная цель которого - принимать и отдавать сообщения. Правда, это не то почтовое отделение, к которому мы все привыкли. Он все-таки гарантирует, что почтальон рано или поздно доставит сообщение адресату, и не занимается вещами, которые не связаны с почтой.

В протоколе AMQP используются следующие понятия:

Поставщик (producer) - программа, отправляющая сообщения.
Подписчик (consumer) - программа, которая забирает сообщения из очереди. Она ждет, пока в очереди появится сообщение, забирает и обрабатывает его.
Очередь (queue) - сердце системы, через которое общаются поставщик и подписчик.
Обработчик (exchange) - позволяет создавать маршрутизацию сообщений по очередям.
Начнем с простой схемы общения - через очередь, без участия обработчика.

Любое количество поставщиков или подписчиков может использовать одну или несколько очередей. Причем очереди могут быть разных типов и храниться в памяти или на диске (durable). Сообщения в них могут содержать TTL для сообщений и уведомления о доставке. Часто поставщик, очередь и подписчик находятся на разных физических машинах.

Ниже представлен скрипт на Python, который использует библиотеку pika для работы с RabbitMQ:

Обращаем ваше внимание что данный скрипт требует версию python не выше 2.7 и установленную библиотеку pika. Установить данную библиотеку можно через менеджер пакетов pip, такой командой pip install pika. В свою очередь pika требует для работы enum. Установим её командой pip install enum.

# cat send.py
#!/usr/bin/env python
import pika
import sys

connection = pika.BlockingConnection(pika.ConnectionParameters(
        host='localhost')) # предполагаем, что RabbitMQ запущен на том же сервере, где и запускается скрипт
channel = connection.channel()

channel.queue_declare(queue='hello') # создаем очередь "hello", которую будем использовать для отправки сообщений. Если очередь создана с такими же параметрами, как запрошено в коде, то скрипт будет использовать ее

channel.basic_publish(exchange='',
                      routing_key='hello',
                      body=sys.argv[1]) # отправляем сообщение в очередь БЕЗ использования обработчика
print " [x] Sent 'Hello World!'"
connection.close()

# python send.py "Hello World"
 [x] Sent 'Hello World!'
После вызова данного скрипта в очереди hello появится одно сообщение. Посмотреть размер очереди можно с помощью утилиты rabbitmqctl. Ниже показано, что в очереди hello содержится одно сообщение.

~# rabbitmqctl list_queues
Timeout: 60.0 seconds ...
Listing queues for vhost / ...
hello	1

# для успешного выполнения команды rabbitmqadmin, должен быть предварительно включен плагин rabbitmq_management

~# rabbitmqadmin get queue='hello'
+-------------+----------+---------------+--------------+---------------+------------------+------------+-------------+
| routing_key | exchange | message_count |   payload    | payload_bytes | payload_encoding | properties | redelivered |
+-------------+----------+---------------+--------------+---------------+------------------+------------+-------------+
| hello       |          | 0             | Hello World | 11            | string           |            | False       |
+-------------+----------+---------------+--------------+---------------+------------------+------------+-------------+
Давайте теперь получим сообщения, лежащие в очереди. Ниже представлен скрипт, который печатает queue сообщения из очереди:

#!/usr/bin/env python
import pika

connection = pika.BlockingConnection(pika.ConnectionParameters(
        host='localhost'))
channel = connection.channel()

channel.queue_declare(queue='hello')

print ' [*] Waiting for messages. To exit press CTRL+C'

def callback(ch, method, properties, body): # функция обработчик сообщений, у которой предопределены параметры, которые будет передавать обвязка pika ниже
    print " [x] Received %r" % (body,)

channel.basic_consume('hello',
                      callback,
                      no_ack=True) # говорим, что мы слушаем очередь "hello", каждое сообщение обрабатывается функцией "callback", и брокер не должен ждать ответа об обработке

channel.start_consuming() # начинаем бесконечную обработку сообщений
Данный скрипт выведет сообщение Hello World, которое мы отправили в очередь. А также он будет ждать новых сообщений в очереди и печатать их:

# python receive.py
 [*] Waiting for messages. To exit press CTRL+C
 [x] Received 'Hello World'
Это был простой пример, который позволяет передавать сообщения через RabbitMQ, однако реальные приложения используют обработчики (в документации - exchanges), которые позволяют делать маршрутизацию пакетов по следующим сценариям:

Fanout - к обработчику привязываются несколько очередей, в каждую из которых отправляется по сообщению, когда кто-то отправляет сообщение в обработчик.
Direct - позволяет использовать особый ключ binding_key (routing_key), по которому можно разделить, какая нагрузка куда должна идти. Позволяет через один exchange раскидывать разные виды задач - к примеру, отправка SMS или E-Mail разными путями.
Данные методы можно комбинировать - то есть, в целом, можно использовать метод Direct, но назначать у двух очередей одинаковый binding_key, если требуется разная обработка или же хочется просто временно сохранять все сообщения, которые приходят на обработчик, чтобы обработать или проанализировать потом.

Кроме того, RabbitMQ может оперировать понятием Virtual Host, который по аналогии с nginx позволяет логически разделить очереди по своеобразным пространствам, которые не будут пересекаться.

Также RabbitMQ предоставляет большую функциональность в виде HTTP интерфейса. Чтобы воспользовать им, нужно включить плагин:

# rabbitmq-plugins enable rabbitmq_management
Веб-интерфейс доступен на 15672 порту, предоставляет информацию по пользователям, очередям, показывает различные графики. Также он позволяет управлять сущностями брокера - создавать/удалять/изменять права пользователей, работать с очередями и обработчиками, конфигурировать работу самого брокера, к примеру, настроить политику создания очередей в режиме высокой доступности (это актуально при кластеризации).

При первоначальной настройке стоит добавить нового пользователя с правами администратора и удалить пользователя guest, а для всех сервисов создавать сервисных пользователей, от имени которых и производить подключение.

Стоит также упомянуть, что RabbitMQ умеет работать в режиме кластера, что может позволить создать более отказоустойчивую инфраструктуру, однако часто однонодовый RabbitMQ позволяет обрабатывать большие объемы сообщений без проблем.

Полезные ссылки:
Официальная документация
Which protocols does RabbitMQ support?
RabbitMQ – Что такое RabbitMQ?
Документация Pika
Clustering Guide
