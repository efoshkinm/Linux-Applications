Задание:
Сгенерируйте самоподписанный сертификат для домена test.linux.example.com при помощи утилиты openssl с использованием параметра -subj (сохраните команду и сертификат).
Установите certbot (сохраните команды для установки).
Получите сертификат для вашего доменного имени при помощи webroot через nginx, используя директорию /var/www/html как корень (сохраните команды запуска).
Настройте автоматическое обновление сертификата и применения его на стороне nginx при помощи hook (сохраните команды).
Дополните конфигурационный файл nginx на использование TLS.
Добавить правило для автоматичесого редиректа на HTTPS в default конфиге.
Предоставить команды, конфигурационные файлы nginx, сертификат (полученный в п.3 Задания) и ссылку на сайт.


*********************************************************************
Решение
*********************************************************************
Ефошкин Максим Вячеславович
ОТПРАВЛЕНО
24.06.2022 09:51
Настройка сервера
[m.efoshkin@MiWiFi-R4A-srv ~]$ yc compute instance create     --name efoshkin-lnxa-01-06     --network-interface subnet-name=default-ru-central1-b,nat-ip-version=ipv4     --zone ru-central1-b     --ssh-key ~/.ssh/id_rsa.pub     --cores 2     --core-fraction 5     --preemptible     --create-boot-disk image-folder-id=standard-images,image-family=ubuntu-2004-lts     --labels user_email=maxefoshkin@gmail.com,task_name=lnxa-01-06
done (22s)
id: epd3g07c0e95n8ta2dn7
folder_id: b1gu2vqv4hil3okf70bb
created_at: "2022-06-23T05:40:44Z"
name: efoshkin-lnxa-01-06
labels:
  task_name: lnxa-01-06
  user_email: maxefoshkin@gmail.com
zone_id: ru-central1-b
platform_id: standard-v2
resources:
  memory: "2147483648"
  cores: "2"
  core_fraction: "5"
status: RUNNING
boot_disk:
  mode: READ_WRITE
  device_name: epd48gelob1p06ff57v7
  auto_delete: true
  disk_id: epd48gelob1p06ff57v7
network_interfaces:
- index: "0"
  mac_address: d0:0d:38:00:ec:03
  subnet_id: e2lebfr9cjkjg4ruk3gn
  primary_v4_address:
    address: 10.129.0.45
    one_to_one_nat:
      address: 84.201.179.161
      ip_version: IPV4
fqdn: epd3g07c0e95n8ta2dn7.auto.internal
scheduling_policy:
  preemptible: true
network_settings:
  type: STANDARD
placement_policy: {}

There is a new yc version '0.91.0' available. Current version: '0.90.0'.
See release notes at https://cloud.yandex.ru/docs/cli/release-notes
You can install it by running the following command in your shell:
	$ yc components update

Сгенерируйте самоподписанный сертификат для домена test.linux.example.com при помощи утилиты openssl с использованием параметра -subj (сохраните команду и сертификат).
root@epd3g07c0e95n8ta2dn7:/etc/nginx# openssl req -x509 -sha256 -nodes -days 365 -newkey rsa:2048 -keyout privateKey.key -out certificate.crt -subj "/C=RU/ST=Moscow/L=Moscow/O=Rebrainme/CN=test.linux.example.com"
Generating a RSA private key
..................................................................................................................+++++
..........+++++
writing new private key to 'privateKey.key'
-----
root@epd3g07c0e95n8ta2dn7:/etc/nginx# ll privateKey.key 
-rw------- 1 root root 1708 Jun 23 06:06 privateKey.key
root@epd3g07c0e95n8ta2dn7:/etc/nginx# vi privateKey.key 
root@epd3g07c0e95n8ta2dn7:/etc/nginx# ll certificate.crt 
-rw-r--r-- 1 root root 1330 Jun 23 06:06 certificate.crt
root@epd3g07c0e95n8ta2dn7:/etc/nginx# vi certificate.crt 
root@epd3g07c0e95n8ta2dn7:/etc/nginx# 



root@epd3g07c0e95n8ta2dn7:/etc/nginx# apt-get install certbot
root@epd3g07c0e95n8ta2dn7:/etc/letsencrypt# ll
total 12
drwxr-xr-x  2 root root 4096 Jun 23 06:11 ./
drwxr-xr-x 80 root root 4096 Jun 23 06:11 ../
-rw-r--r--  1 root root  121 Feb 11  2019 cli.ini
root@epd3g07c0e95n8ta2dn7:/etc/letsencrypt# pwd
/etc/letsencrypt
root@epd3g07c0e95n8ta2dn7:/etc/letsencrypt# 




Получите сертификат для вашего доменного имени при помощи webroot через nginx, используя директорию /var/www/html как корень (сохраните команды запуска).
root@epd3g07c0e95n8ta2dn7:/etc/nginx# certbot certonly  --webroot -w /var/www/html -d 84.201.179.161.nip.io -m m.efoshkin@yandex.ru
Saving debug log to /var/log/letsencrypt/letsencrypt.log
Plugins selected: Authenticator webroot, Installer None
Obtaining a new certificate
Performing the following challenges:
http-01 challenge for 84.201.179.161.nip.io
Using the webroot path /var/www/html for all unmatched domains.
Waiting for verification...
Cleaning up challenges
Running deploy-hook command: systemctl reload nginx

IMPORTANT NOTES:
 - Congratulations! Your certificate and chain have been saved at:
   /etc/letsencrypt/live/84.201.179.161.nip.io/fullchain.pem
   Your key file has been saved at:
   /etc/letsencrypt/live/84.201.179.161.nip.io/privkey.pem
   Your cert will expire on 2022-09-22. To obtain a new or tweaked
   version of this certificate in the future, simply run certbot
   again. To non-interactively renew *all* of your certificates, run
   "certbot renew"
 - If you like Certbot, please consider supporting our work by:

   Donating to ISRG / Let's Encrypt:   https://letsencrypt.org/donate
   Donating to EFF:                    https://eff.org/donate-le

root@epd3g07c0e95n8ta2dn7:/etc/nginx# 



Настройте автоматическое обновление сертификата и применения его на стороне nginx при помощи hook (сохраните команды).
root@epd3g07c0e95n8ta2dn7# cat /etc/cron.d/certbot
0 */12 * * * root test -x /usr/bin/certbot -a \! -d /run/systemd/system && perl -e 'sleep int(rand(43200))' && certbot -q renew


root@epd3g07c0e95n8ta2dn7:/etc/letsencrypt# cat cli.ini 
# Because we are using logrotate for greater flexibility, disable the
# internal certbot logrotation.
max-log-backups = 0
deploy-hook = systemctl reload nginx
root@epd3g07c0e95n8ta2dn7:/etc/letsencrypt# 


root@epd3g07c0e95n8ta2dn7:/etc/letsencrypt/live/84.201.179.161.nip.io# certbot renew --dry-run
Saving debug log to /var/log/letsencrypt/letsencrypt.log

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
Processing /etc/letsencrypt/renewal/84.201.179.161.nip.io.conf
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
Cert not due for renewal, but simulating renewal for dry run
Plugins selected: Authenticator webroot, Installer None
Renewing an existing certificate
Performing the following challenges:
http-01 challenge for 84.201.179.161.nip.io
Using the webroot path /var/www/html for all unmatched domains.
Waiting for verification...
Cleaning up challenges
Dry run: skipping deploy hook command: systemctl reload nginx

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
new certificate deployed without reload, fullchain is
/etc/letsencrypt/live/84.201.179.161.nip.io/fullchain.pem
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
** DRY RUN: simulating 'certbot renew' close to cert expiry
**          (The test certificates below have not been saved.)

Congratulations, all renewals succeeded. The following certs have been renewed:
  /etc/letsencrypt/live/84.201.179.161.nip.io/fullchain.pem (success)
** DRY RUN: simulating 'certbot renew' close to cert expiry
**          (The test certificates above have not been saved.)
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

IMPORTANT NOTES:
 - Your account credentials have been saved in your Certbot
   configuration directory at /etc/letsencrypt. You should make a
   secure backup of this folder now. This configuration directory will
   also contain certificates and private keys obtained by Certbot so
   making regular backups of this folder is ideal.
root@epd3g07c0e95n8ta2dn7:/etc/letsencrypt/live/84.201.179.161.nip.io# 
root@epd3g07c0e95n8ta2dn7:/etc/letsencrypt/archive/84.201.179.161.nip.io# cat /etc/nginx/sites-enabled/nip 
log_format logz '$remote_addr [$time_local]'
                '"$request" $status';
								
server {
       listen 80;
       listen 443 ssl;
       server_name 84.201.179.161.nip.io;
       ssl_certificate  /etc/letsencrypt/archive/84.201.179.161.nip.io/cert1.pem;
       ssl_certificate_key  /etc/letsencrypt/archive/84.201.179.161.nip.io/privkey1.pem;
       ssl_protocols       TLSv1 TLSv1.1 TLSv1.2;
       ssl_ciphers         HIGH:!aNULL:!MD5;

       root /var/www/html;
       index index.nginx-debian.html;
      } 
     
root@epd3g07c0e95n8ta2dn7:/etc/letsencrypt/archive/84.201.179.161.nip.io# 


РАюотает! Ура!! Я первый раз настроил настоящий сертификат, это круто! Я рад, спасибо! 84.201.179.161.nip.io

ОТВЕТ КУРАТОРА
Oleg Avdeev (@oavdeev)
ВЫПОЛНЕНО 4
24.06.2022 20:27
Максим, здравствуйте! Хорошая работа, всего пара незначительных замечаний.

по п.4 требуется уточнение: скорее всего в вашей системе есть каталог /run/systemd/system, значит из этого кронтаба certbot не запустится. Как он запускается в таком случае ?
забыли реализовать: "Добавить правило для автоматичесого редиректа на HTTPS в default конфиге."
27.06.2022 14:59
ВЫПОЛНЕНО 5
Ефошкин Максим Вячеславович
ОТПРАВЛЕНО
27.06.2022 14:59
Он запускается через systemd-timers
Я не забыл про редирект. Просто, когда я его ставил, он ругался что уже много редиректов. Почемуто nginx не запускался.
Вот, щас я заново подниму виртуалку.

[m.efoshkin@fedora ~]$ yc compute instance create     --name efoshkin-lnxa-01-06     --network-interface subnet-name=default-ru-central1-b,nat-ip-version=ipv4     --zone ru-central1-b     --ssh-key ~/.ssh/id_rsa.pub     --cores 2     --core-fraction 5     --preemptible     --create-boot-disk image-folder-id=standard-images,image-family=ubuntu-2004-lts     --labels user_email=maxefoshkin@gmail.com,task_name=lnxa-01-06
done (28s)
id: epdjgg6lrmo0tmcl6ih8
folder_id: b1gu2vqv4hil3okf70bb
created_at: "2022-06-27T10:59:21Z"
name: efoshkin-lnxa-01-06
labels:
  task_name: lnxa-01-06
  user_email: maxefoshkin@gmail.com
zone_id: ru-central1-b
platform_id: standard-v2
resources:
  memory: "2147483648"
  cores: "2"
  core_fraction: "5"
status: RUNNING
boot_disk:
  mode: READ_WRITE
  device_name: epdstil5q264tpk7i1n8
  auto_delete: true
  disk_id: epdstil5q264tpk7i1n8
network_interfaces:
- index: "0"
  mac_address: d0:0d:13:84:0d:5d
  subnet_id: e2lebfr9cjkjg4ruk3gn
  primary_v4_address:
    address: 10.129.0.29
    one_to_one_nat:
      address: 84.252.139.85
      ip_version: IPV4
fqdn: epdjgg6lrmo0tmcl6ih8.auto.internal
scheduling_policy:
  preemptible: true
network_settings:
  type: STANDARD
placement_policy: {}



apt-get install certbot
apt-get install nginx-full

# Генерация сертифифкатов
certbot certonly  --webroot -w /var/www/html -d 84.252.139.85.nip.io -m m.efoshkin@yandex.ru


Разобрался с редиректами
root@epdjgg6lrmo0tmcl6ih8:/etc/nginx/sites-enabled# cat nip 
log_format logz '$remote_addr [$time_local]'
                '"$request" $status';


server {
       listen 80;
       server_name    84.252.139.85.nip.io;

       return 301 https://84.252.139.85.nip.io$request_uri;

       }
								
server {
       listen 443 ssl;
       server_name 84.252.139.85.nip.io;
       ssl_certificate  /etc/letsencrypt/live/84.252.139.85.nip.io/fullchain.pem;
       ssl_certificate_key  /etc/letsencrypt/live/84.252.139.85.nip.io/privkey.pem;
       ssl_protocols       TLSv1 TLSv1.1 TLSv1.2;
       ssl_ciphers         HIGH:!aNULL:!MD5;

       root /var/www/html;
       index index.nginx-debian.html;
      } 



И регенерация сертификатов
root@epdjgg6lrmo0tmcl6ih8:/etc/letsencrypt# cat cli.ini 
# Because we are using logrotate for greater flexibility, disable the
# internal certbot logrotation.
max-log-backups = 0
deploy-hook = systemctl reload nginx
root@epdjgg6lrmo0tmcl6ih8:/etc/letsencrypt# 

root@epdjgg6lrmo0tmcl6ih8:/etc/letsencrypt# systemctl status certbot.timer
● certbot.timer - Run certbot twice daily
     Loaded: loaded (/lib/systemd/system/certbot.timer; enabled; vendor preset: enabled)
     Active: active (waiting) since Mon 2022-06-27 11:03:13 UTC; 51min ago
    Trigger: Mon 2022-06-27 17:35:21 UTC; 5h 40min left
   Triggers: ● certbot.service

Jun 27 11:03:13 epdjgg6lrmo0tmcl6ih8 systemd[1]: Started Run certbot twice daily.
root@epdjgg6lrmo0tmcl6ih8:/etc/letsencrypt# 

root@epdjgg6lrmo0tmcl6ih8:/etc/letsencrypt# systemctl cat certbot.timer
# /lib/systemd/system/certbot.timer
[Unit]
Description=Run certbot twice daily

[Timer]
OnCalendar=*-*-* 00,12:00:00
RandomizedDelaySec=43200
Persistent=true

[Install]
WantedBy=timers.target


Как я понял, он запускает certbot renew  два раза в день. И типа когда сертификат протухает он обновляется? 
А если он не протух, но получается он два раза запускает его в холостую?

Проверка 84.252.139.85.nip.io

ОТВЕТ КУРАТОРА
Oleg Avdeev (@oavdeev)
ВЫПОЛНЕНО 5
28.06.2022 12:56
Максим, здравствуйте! Отлично, считаю что с темой отлично разобрались, редирект работает.

Как я понял, он запускает certbot renew два раза в день. И типа когда сертификат протухает он обновляется? А если он не протух, но получается он два раза запускает его в холостую?

Не совсем так, цертбот не ждёт пока серитификат окончательно протухнет и выполнит обновление заранее, за 30 дней до истечения срока. Это делается специально, чтобы не допустить чтобы клиент попал на страницу с просроченным сертификатом даже если часть попыток обновления завершится неудачно. Когда сертификат валидный и до его истечения >30 дней, certbоt ничего не делает, можно сказать что холостой запуск.


*************************************************************************************
Теория
*************************************************************************************

LNXA-01 06: Web. Let's encrypt
Описание:
Когда Интернет только появлялся, он использовался для передачи данных между людьми и за счет небольшого распространения доступа подразумевалось, что мы можем доверять каждому звену (особенно во времена, когда в ARPANET - предтечу Интернета - входили только университеты и оборонка), а значит, и средств защиты свыше пароля не требовалось. Однако сейчас, когда на Интернете завязано все - от просмотра развлекательного контента до выполнения платежей - требуется более стойкий и более прозрачный для пользователя метод связи. Для этих целей сейчас используется расширение протокола HTTP под названием HTTPS, где S расшифровывается как Secure, которое при помощи другого протокола TLS (Transport Layer Security) производит шифрование данных между запрашиваемым сервером и клиентом, защищая канал общения от чужих глаз.

Для того чтобы подключиться к серверу, работающему по HTTPS, требуется сначала совершить так называемый TLS Handshake, чтобы договориться с сервером, какие ключи шифрования будут использоваться для шифрования данных между клиентом и сервером. Но перед тем, как мы начнем разбирать, как производится TLS Handshake, разберем, что такое TLS сертификат.

Условно, TLS сертификат - это файл, который содержит следующую информацию:

Кто выписал этот сертификат - требуется, чтобы определить, можно ли доверять этому сертификату.
На какой DNS-адрес (или адреса, или даже множества адресов) выписан данный сертификат - позволяет определить, валидно ли использование этого сертификата для конкретного адреса.
Публичная часть ключа того, кому выдали сертификат - она используется пользователями в ходе TLS handshake для шифрования параметров установления сессионного ключа шифрования.
Подпись сертификата - это данные, зашифрованные приватным ключом выписывающего сертфиката, которые пользователь при установлении соединения может расшифровать при помощи публичного ключа выписывающего сертификата и сравнить полученные данные с образцовыми, которые также содержатся в сертификате. В случае, если данные сходятся, то факт подписи сертификата считается подтвержденным, а значит, сертификату можно доверять на уровне подписи.
Период валидности сертификата - позволяет проверить, актуален ли сертификат.
В пунктах выше фигурируют понятия приватного и публичного ключа - эти понятия связаны с алгоритмами шифрования, которые называются асимметричными или криптосистемами с открытым ключом, то есть, в которых для шифрования и расшифровки данных используются 2 разных ключа, связанных друг с другом. Ключи позволяют делать следующее:

приватный ключ позволяет расшифровать зашифрованное публичным ключом;
публичный ключ позволяет зашифровать данные, которые можно расшифровать только приватным ключем;
из приватного ключа можно получить публичный ключ;
из публичного ключа нельзя получить приватный ключ.
Плюсом использования асинхронных ключей является возможность отправлять на сервер (где хранится приватный ключ) данные, которые защищены сразу за счет криптографической сложности подбора ключа.

Вернемся к разбору TLS Handshake. Упрощенно, схема сводится к тому, чтобы:

Получить у сервера TLS сертификат, подтверждающий, что мы обращаемся к нужному хосту и содержащий необходимый публичный ключ шифрования.
Проверить, что сертификат выписан именно для запрашиваемого домена.
Проверить, что сертификат выписан именно тем сертификатом, который указан в нем.
Зашифровать наши параметры для генерации ключей шифрования передачи данных при помощи публичного ключа из сертификата и отправить на сервер.
Получить от сервера его параметры шифрования, которые зашифрованы при помощи приватного ключа.
При помощи соединения наших параметров и параметров сервера генерируется сессионный ключ, который будет использоваться при общении между сервером и клиентом при помощи синхронного алгоритма шифрования.
Обмен параметрами генерации ключа производится, как правило, по протоколу Диффи — Хеллмана. Его логику можно описать так: мы отправляем копию карты одному человеку, а он нам присылает трафарет с отметкой, где мы встретимся. Лишь обладая обеими частями данного обмена, мы можем узнать, где будет встреча. Но, скажем, если мы отправляем карту в бронированном автомобиле, а вторая сторона - почтой, то вероятность для третьей стороны получить обе части сильно уменьшается (хотя с почтой, конечно, есть вероятность вообще никому не получить вторую часть, но это уже проблема на транспортном уровне).

Синхронные (симметричные) алгоритмы шифрования, в отличие от асинхронных (асимметричных), требуют меньших ресурсов для использования, вплоть до реализации некоторых на уровне процессоров, из-за чего и используются повсеместно.

Стоит еще упомянуть, что до TLS сущестовал другой алгоритм - SSL (Secure Sockets Layer), который является прародителем TLS, но ввиду его уязвимости, он сейчас не рекомендуется к использованию.

Однако и с TLS дела непросты - данный протокол также имеет несколько версий, которые могут быть несовместимы между друг другом, иметь разные возможности и поддерживаемые алгоритмы шифрования. Так, к примеру, версия 1.3 сильно подчистила список алгоритмов шифрования, которые поддерживает, а также укоротила сценарий TLS Handshake с 10 шагов до 3 в нормальном сценарии, а то и до 1 (0-RTT - подразумевается, что соединение уже устанавливалось и ключ еще недостаточно устарел, чтобы его требовалось обновлять в рамках сессии).

В криптосистемах с открытым ключом существует такое понятие, как доверие. Оно означает, что мы, как пользователи, доверяем группе сертификатов, которые называются корневыми и при помощи которых подписываются другие сертификаты иерархией ниже. В случае, если мы не доверяем конкретному корневому сертификату или даже перестали доверять (скажем, из-за компрометации сертификата), то мы также перестаем доверять всем сертификатам иерархией выше.

Пожалуй, на этом мы закончим теоретический блок, связанный с тем, что такое криптосистемы с открытыми ключами и перейдем к теории о том, как они используются в реальном мире. И начнем с того, как мы можем получить сертификат HTTPS для работы. На данный момент существует несколько сценариев:

Подписать сертификат себе самому - заключается в создании сертификата и одновременного подписания его своим же приватным ключем. Данный метод может использоваться как для создания собственного корневого сертификата, так и для создания тестового сертификата (скажем, для приватной инфраструктуры компании).
Купить сертификат у определенной компании - позволяет заказать сертификат, который вы и будете использовать. В зависимости от вида сертификата, удостоверяющего центра и компании, которая продает сертификаты, цена может варьироваться от нескольких сотен рублей до десятков тысяч.
Получение сертификата через удостоверяющй центр Let's Encrypt - бесплатное и автоматизированное решение, созданное с целью распространения HTTPS в мире.
Перед разбором каждого из описанных методов, стоит разобрать, чем сертификаты различаются. Глобально их можно разделить по методу верификации и на какие домены распространяется.

По методу верификации сертификаты разделяются на:

Проверка домена (Domain Validation - DV) - самый простой метод, который дает самый простой сертификат, позволяющий использовать его на любом конкретном домене.
Проверка организации (Organization Validation - OV) - метод, завязанный на компании, часто требующий отправить данные о компании на проверку.
Расширенная проверка (Extended Validation - EV) - расширенный вариант OV, который требует заполнения специальных форм и в итоге позволяет получить сертификат, который ранее отображал имя вашей компании в адресной строке рядом с замком, но сейчас это не производится современными браузерами.
По распространению на домены сертификаты разделяются на:

На домен - позволяет выписать сертификат на конкретный домен, к примеру, www.example.com. При этом не будет распространяться на другие домены, типа example.com или new.example.com.
На несколько доменов - позволяет при помощи специального поля SAN (Subject Alternative Name) задать для одного сертификата несколько разрешенных имен. К примеру, на example.com и на www.example.com.
На поддомен - распространяется на группу поддоменов, отмеченных *. Пример - *.example.com, который будет распространяться на www.example.com, new.example.com, но при этом не будет распространяться на example.com (правда, сейчас почти все удостоверяющие центры к wildcard добавляют еще и SAN с основным доменом).
Теперь разберем, как можно получить сертификат любым из 3 методов:

Самоподписанный сертификат
Данный метод подразумевает создание сертификата и подписание его же при помощи своего ключа. При помощи утилиты openssl (которая, по факту, является швейцарским ножом для работы со всем, что может быть связано с шифрованием и TLS сертификатами, в частности), создание такого сертификата производится одной командой:

openssl req -x509 -sha256 -nodes -days 365 -newkey rsa:2048 -keyout privateKey.key -out certificate.crt -subj "/C=US/ST=Denial/L=Springfield/O=Dis/CN=www.example.com"

Данная команда начнет диалог по созданию сертификата certificate.crt, при приватном ключе privateKey.key, валидном в течение 365 дней, где в роли алгоритма асинхронного шифрования используется протокол RSA с размером ключа в 2048 байт и алгоритмом подсчета подписи SHA256.

В рамках диалога будут запрошены следующие поля:

Country Name (C) - страна, к которой привязан сертфикат, - необходимо только при генерации сертификатов типа OV и EV либо может использоваться для корневых сертификатов (CA - Certificate Authority). В рамках создания самоподписанного сертификата создается как раз CA сертификат, но так как мы создаем его для себя, то можно оставить этот параметр пустым.
State or Province Name (ST) - район, к которому привязана компания - все аналогично параметру выше.
Locality Name (L) - имя города, к которому привязана компания - аналогично.
Organization Name (O) - имя компании - аналогично.
Organizational Unit Name (OU) - имя подразделения - аналогично.
Common Name (CN) - сертификат, для кого выдается сертификат - самое важное поле, в нем должен быть указан адрес, для которого выписывается сертификат.
Email Address (E) - адрес, для кого выдан сертификат, - аналогичные требования, как с Country Name.
Для создания сертификата без ввода данных можно использовать параметр -subj:

openssl req -x509 -sha256 -nodes -days 365 -newkey rsa:2048 -keyout privateKey.key -out certificate.crt -subj "/C=US/ST=Denial/L=Springfield/O=Dis/CN=www.example.com"

Напрашивается вопрос, зачем вообще столько информации указывать? Связано это с тем, что сертификаты сами по себе - универсальное средство, которое используется не только для HTTPS, но и для других целей, таких как Электронная Цифровая Подпись, создание ключей доступа и подключение хостов по другим протоколам (к примеру, RDP).

Приобретение сертификата
Здесь мы не будем рассматривать все этапы подтверждения, а разберем лишь техническую часть - генерацию запроса на подписание сертификата. Этот этап также можно производить через утилиту openssl:

openssl req -out CSR.csr -new -newkey rsa:2048 -nodes -keyout privateKey.key

Как можно заметить, в обоих случая используются подкоманды req, но при генерации запроса на подписание мы не указываем срок подписания (его указывает удостоверяющий центр) и протокол подписания. В запросе содержится публичный ключ и запрашиваемые данные, в том числе требуемый домен. Важно то, что приватный ключ должен оставаться у вас и только у вас и не предоставляться удостоверяющему центру. Аналогично с генерацией самоподписанного сертификата мы можем сгенерировать запрос без интерактивного режима при помощи все того же параметра -subj.

Получение при помощи Let's Encrypt
Наконец мы дошли до гвоздя программы - автоматизированного удостоверяющего центра Let's Encrypt.

Он позволяет получать бесплатные сертификаты любого формата распространения на домены без звонков, заполнения заявок и прочих вещей.

Let's Encrypt появился как проект, созданный объединением таких компаний, как Mozilla, Cisco, EFF и сотни других с целью распространения HTTPS везде и как можно быстрее в свете современных реалий Интернета. Получение сертификатов подразумевает использование автоматизированных средств, которые общаются с сервером авторизации по протоколу ACME, работающему по следующей схеме:

Мы запрашиваем сертификат на конкретный домен/группу доменов/поддомен с определенным методом проверки.
Сервер авторизации сообщает, какие действия требуется сделать для подтверждения запроса.
Они выполняются, отправляется запрос на проверку.
Проверка проводится, в результате генерируется сертификат, который запрашивал пользователь.
Данный сертификат скачивается и сохраняется в системе.
Однако удобство накладывает определенные ограничения:

Выдаваемый сертификат выдается на 90 дней (но перед окончанием на почту, зарегистрированную при запросе, присылается уведомление о необходимости обновления).
На один домен запрещается запрашивать более 50 сертификатов в неделю.
Один сертификат не может содержать более 100 SAN.
В неделю запрещается делать более 5 повторных запросов сертификатов.
В течение часа запрещается делать более 5 неудачных валидаций.
В течение секунды запрещается делать более 20 запросов на создание сертификатов.
Как правило, при правильном использовании клиента авторизации в ограничения сложно упереться, но знание об этих ограничениях стоит учитывать.

Что касается клиентов для запросов сертификатов, они подразумевают реализацию клиента для протокола ACME. На данный момент существует большое количество как отдельных клиентов, так и библиотек для работы на разных языках. Официально рекомендумым клиентом является certbot, однако существуют и другие решения, вплоть до acme.sh, написанного на shell.

Существует несколько видов запросов на создание протоколов:

HTTP-01 - подразумевает создание файла-токена (с именем, которое отдает удостоверяющий сервер), который при проверке должен быть доступен по адресу http://<YOUR_DOMAIN>/.well-known/acme-challenge/<TOKEN> - данный метод позволяет получить сертификаты на домен и сертификаты с несколькими доменами.
DNS-01 - подразумевает создание TXT DNS-записи типа _acme-challenge.<YOUR_DOMAIN> с переданным токеном, которую запрашивает удостоверяющий сервер. Поскольку данный метод подразумевает автоматизированное обновление, оно требует обращение к DNS-провайдеру через API, а значит, и провайдера, который имеет API (к примеру, CloudFlare, Google Cloud, DigitalOcean, Yandex Connect). Позволяет получать любой вид сертификатов - на домен, на несколько доменов и wildcard домены. Также может быть использован для получения доменов в вашей частной инфраструктуре, где для адресов используются частные адреса.
TLS-ALPN-01 - специальный метод подтверждения, требующий реализации на уровне приложения для установки поля SNI, поэтому практически нигде не используется (из примеров использования можно привести, пожалуй, reverse proxy Caddy).
В рамках этого задания мы будем рассматривать только метод HTTP-01, как наиболее простой в реализации и самый распространенный. Имея установленный в вашей системе certbot и установив корректную DNS-запись на ваш адрес, вы можете запросить сертификат на вашем сервере при помощи следующей команды:

certbot certonly --standalone -d example.com -m admin@example.com

Разберем команду:

certonly - означает только получить сертификат, не устанавливая его;
--standalone - запустить собственный веб-сервер на порту 80 для прохождения верификации;
-d example.com - указываем, для какого домена мы запрашиваем сертификат;
-m admin@example.com - какая почта должна быть связана с этим доменом (используется для оповещений от Let's Encrypt).
Интересным параметром является второй - он позволяет задать, как мы будем подтверждать сертификат. По умолчанию доступны следующие методы:

--standalone - мы его рассмотрели выше;
--webroot - используется в связке с другими веб-серверами и подразумевает указание директории, в которую требуется сохранить токен. Подразумевается, что эта директория отдает путь /.well-known/acme-challenge/;
--manual - используется для ручного подтверждения.
Кроме приведенных методов, существуют и другие методы, которые устанавливаются при помощи плагинов. Так, к примеру, пакет python3-certbot-nginx позволит работать с nginx, вплоть до того, что он позволит сам изменить конфигурацию nginx под эти нужды.

Как мы говорили, Let's Encrypt выдает сертификаты всего на 90 дней, поэтому требуется обновлять сертификаты автоматизированно. Для этого существует команда certonly renew, которая должна быть добавлена в периодические задачи (к примеру, cron) и будет обновлять все настроенные сертификаты.

Файлы certbot хранятся в директории /etc/letsencrypt/:

root@analytics-dev:/etc/letsencrypt# tree .
.
├── accounts # директория содержит аккаунты, к которым привязаны сертификаты
├── archive # директория содержит сертификаты каждого домена
│   └── example.com # количество файлов в директории, связанной с доменом, будет расти в зависимости от того, сколько раз обновлялся сертификат
│       ├── cert1.pem
│       ├── cert2.pem
│       ├── chain1.pem
│       ├── chain2.pem
│       ├── fullchain1.pem
│       ├── fullchain2.pem
│       ├── privkey1.pem
│       └── privkey2.pem
├── cli.ini # конфигурационный файл certbot
├── csr # директория содержит запросы на подпись сертификатов, отправляемых на удостоверяющий центр
├── keys # директория содержит ключи для сертификатов
├── live # директория с актуальными сертификатами, разделенными по доменам
│   └── example.com # пример директории с сертификатами под домен
│       ├── README # описание файлов
│       ├── cert.pem -> ../../archive/example.com/cert2.pem # ссылка до файла с сертификатом
│       ├── chain.pem -> ../../archive/example.com/chain2.pem # ссылка до файла с промежуточными сертификатами
│       ├── fullchain.pem -> ../../archive/example.com/fullchain2.pem # ссылка до файла, содержащего промежуточный сертификат и сам сертификат (как правило, он и используется)
│       └── privkey.pem -> ../../archive/example.com/privkey2.pem # приватный ключ сертификата
├── renewal # директория с конфигурационными файлами, описывающая, каким образом обновлять сертификаты
│   └── example.com.conf
├── renewal-hooks # директория с хуками, разделенными по ступеням, которые можно использовать при конфигурации сертификата
│   ├── deploy
│   ├── post
│   └── pre
└── ssl-dhparams.pem
При помощи параметров --pre-hook|--post-hook|--deploy-hook и передачи команды/скрипта, которую требуется запустить.

Для удаления сертификата из обработки используется команда certbot delete, в которой в интерактивном режиме выбирается, какие сертификаты требуется удалить.

Теперь рассмотрим, как нам, собственно, использовать сертификат на примере nginx. Для этого существует модуль ngx_http_ssl_module и конкретно директивы ssl_certificate и ssl_certificate_key (на самом деле, еще много других, но их рассмотрение выходит за рамки текущей темы):

server {
  listen 443 ssl; # мы включаем опцию ssl, которая говорит, что общение производится по защищенному каналу

  ssl_certificate /path/to/sslcert.pem; # путь до сертификата
  ssl_certificate_key /path/to/sslcert.key; # путь до приватного ключа, связанного с сертификатом
}
Чтобы узнать больше деталей по конфигурации, вы можете воспользоваться генератором конфигурациооного файла от Mozilla (ссылку можете найти ниже).

Плюсом упомянем, что если ваш сертификат подразумевает получение сертификата, который использует промежуточный сертификат, он и ваш выписанный сертификат должен быть сохранен в файле с сертификатом для корректной работы. При этом последовательность сертификатов играет роль и при неправильной очередности возникнет ошибка при запросе к серверу.

Полезные ссылки:
ARPANET (wikipedia rus)
Что Такое SSL/TLS И HTTPS? Установка Сертификата Безопасности
Что такое TLS-рукопожатие и как оно устроено
Криптосистема с открытым ключом (wikipedia rus)
Протокол Диффи — Хеллмана (wikipedia rus)
SSL (wikipedia rus)
The Most Common OpenSSL Commands
HTTPS.menu - поиск SSL сертификтов
Let's Encrypt (official)
Пошаговое описание процессов валидации при заказе сертификата
Create an OpenSSL self-signed SAN cert in a single command
Certbot (official)
Виды проверок (let's encrypt docs)
Caddy supports the ACME TLS-ALPN challenge
SSL Configuration Generator
Что такое промежуточный сертификат?
SSL certificate chain resolver
Let's Encrypt: How to Automatically Restart Nginx With Certbot



