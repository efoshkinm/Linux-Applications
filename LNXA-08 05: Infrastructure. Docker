Задание:
Установите последнюю версию Docker runtime из официального репозитория.
Добавьте вашего пользователя в группу для работы с docker от имени непривилегированного пользователя.
Запустите контейнер с образом с nginx из стабильной ветки с именем rebrainme_linux и опубликованным в мир портом 8888, ведущим на порт приложения в контейнере, работающем в фоне и перезапускающемся автоматически всегда (команду и вывод сохраните).
Выведите список работающих контейнеров (команду и вывод сохраните).
Проверьте через браузер доступность nginx по указанному порту.
Перезапустите сервер и еще раз проверьте через браузер доступность nginx по указанному порту.
Выведите список работающих контейнеров (команду и вывод сохраните).
Отправьте на проверку все сохраненные выводы и адрес, по которому можно проверить работу контейнера.


****************************************************************************
Решение
****************************************************************************

Ефошкин Максим Вячеславович
ОТПРАВЛЕНО
16.11.2022 07:04
1. Установите последнюю версию Docker runtime из официального репозитория.
address: 62.84.121.167

 sudo apt-get remove docker docker-engine docker.io containerd runc
 apt  update
 sudo apt-get install ca-certificates curl gnupg lsb-release
 # Добавим ключ
 sudo mkdir -p /etc/apt/keyrings
 curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg
 # Добавляем репозиторий 
 echo \
  "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \
  $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
	# Установка
	apt-get update
	sudo apt-get install docker-ce docker-ce-cli containerd.io docker-compose-plugin
	

### Удаление. Это для истории
apt-get purge docker-ce docker-ce-cli containerd.io docker-compose-plugin
sudo rm -rf /var/lib/docker
sudo rm -rf /var/lib/containerd

2. Добавьте вашего пользователя в группу для работы с docker от имени непривилегированного пользователя.
usermod -aG docker yc-user

3. Запустите контейнер с образом с nginx из стабильной ветки с именем rebrainme_linux и опубликованным в мир портом 8888, ведущим на порт приложения в контейнере, работающем в фоне и перезапускающемся автоматически всегда (команду и вывод сохраните).
docker pull nginx:latest
docker run -d --name rebrainme_linux -p 8888:80 --restart=always nginx

4. Выведите список работающих контейнеров (команду и вывод сохраните).
yc-user@epdgb5nuk03fo2vq966g:~$ docker ps
CONTAINER ID   IMAGE     COMMAND                  CREATED         STATUS         PORTS                                   NAMES
adf0ca2a53fc   nginx     "/docker-entrypoint.…"   6 seconds ago   Up 5 seconds   0.0.0.0:8888->80/tcp, :::8888->80/tcp   rebrainme_linux
yc-user@epdgb5nuk03fo2vq966g:~$ 
5. Проверьте через браузер доступность nginx по указанному порту.
 yc-user@epdgb5nuk03fo2vq966g:~$ curl 62.84.121.167:8888
<!DOCTYPE html>
<html>
<head>
<title>Welcome to nginx!</title>
<style>
html { color-scheme: light dark; }
body { width: 35em; margin: 0 auto;
font-family: Tahoma, Verdana, Arial, sans-serif; }
</style>
</head>
<body>
<h1>Welcome to nginx!</h1>
<p>If you see this page, the nginx web server is successfully installed and
working. Further configuration is required.</p>

<p>For online documentation and support please refer to
<a href="http://nginx.org/">nginx.org</a>.<br/>
Commercial support is available at
<a href="http://nginx.com/">nginx.com</a>.</p>

<p><em>Thank you for using nginx.</em></p>
</body>
</html>
yc-user@epdgb5nuk03fo2vq966g:~$ 
 
 
6. Перезапустите сервер и еще раз проверьте через браузер доступность nginx по указанному порту.
 sudo reboot
yc-user@epdgb5nuk03fo2vq966g:~$ curl 62.84.121.167:8888
<!DOCTYPE html>
<html>
<head>
<title>Welcome to nginx!</title>
<style>
html { color-scheme: light dark; }
body { width: 35em; margin: 0 auto;
font-family: Tahoma, Verdana, Arial, sans-serif; }
</style>
</head>
<body>
<h1>Welcome to nginx!</h1>
<p>If you see this page, the nginx web server is successfully installed and
working. Further configuration is required.</p>

<p>For online documentation and support please refer to
<a href="http://nginx.org/">nginx.org</a>.<br/>
Commercial support is available at
<a href="http://nginx.com/">nginx.com</a>.</p>

<p><em>Thank you for using nginx.</em></p>
</body>
</html>
yc-user@epdgb5nuk03fo2vq966g:~$ 
 
 
7. Выведите список работающих контейнеров (команду и вывод сохраните).
yc-user@epdgb5nuk03fo2vq966g:~$ docker ps
CONTAINER ID   IMAGE     COMMAND                  CREATED         STATUS          PORTS                                   NAMES
adf0ca2a53fc   nginx     "/docker-entrypoint.…"   4 minutes ago   Up 20 seconds   0.0.0.0:8888->80/tcp, :::8888->80/tcp   rebrainme_linux
yc-user@epdgb5nuk03fo2vq966g:~$ 
 
 
curl 62.84.121.167:8888

ОТВЕТ КУРАТОРА
Алексей Кузнецов (@Hystrix)
ВЫПОЛНЕНО 4
16.11.2022 09:07
Добрый день!

Очень хорошо, одно замечание:

п.3. "из стабильной ветки"
16.11.2022 09:52
ВЫПОЛНЕНО 4
Ефошкин Максим Вячеславович
ОТПРАВЛЕНО
16.11.2022 09:52
docker pull nginx:stable
docker run -d --name rebrainme_linux -p 8888:80 --restart=always nginx 
ОТВЕТ КУРАТОРА
Алексей Кузнецов (@Hystrix)
ВЫПОЛНЕНО 4
16.11.2022 10:03
Добрый день!

docker pull nginx:stable
Вы загружаете стабильный образ локально.

docker run -d --name rebrainme_linux -p 8888:80 --restart=always nginx 
но при запуске контейнера используете другой образ. Какой тег у образа по умолчанию?

16.11.2022 10:24
ВЫПОЛНЕНО 5
Ефошкин Максим Вячеславович
ОТПРАВЛЕНО
16.11.2022 10:24
docker pull nginx:stable
docker run -d --name rebrainme_linux -p 8888:80 --restart=always nginx:stable

Дефолтный latest, точно! Спасибо!

ОТВЕТ КУРАТОРА
Алексей Кузнецов (@Hystrix)
ВЫПОЛНЕНО 5
16.11.2022 12:16
Добрый день!

Все верно, тег stable обычно указывает на стабильную ветку, а по умолчанию подставляется latest.

docker pull nginx:stable
не нужно загружать образ, если он уже есть
в принципе можно не загружать явно, если при запуске контейнера образа не будет, то он будет загружен автоматически
Отличные знание темы и выполнение задания, замечаний и вопросов нет!


*****************************************************************************
Теория
*****************************************************************************


LNXA-08 05: Infrastructure. Docker
Описание:
Продолжая тему LXC, разберем еще одну технологию, основанную на контейнеризации и получившую намного бОльшее распространение, - Docker.

Docker – это инструмент, являющийся удобным интерфейсом для работы с контейнерами. Архив с ранее сформированным приложением (образ) запускается в изолированной от самой системы среде (контейнере) с использованием ядра системы, на которой и производится запуск контейнера. Из этого несложно догадаться, что Docker завязан на возможностях Linux. Из-за этого на других системах запуск Docker сводится к запуску Linux в виртуальной среде и предоставлению доступа к нему уже через TCP-сокеты, а не Unix socket, через который демон работает по умолчанию в Linux.

Docker использует следующие возможности Linux:

namespaces - технология, позволяющая изолировать:
сеть;
процесс;
межпроцессорное взаимодействие;
файловые системы;
ядро ОС;
cgroups - позволяет ограничивать контейнер по ресурсам (RAM, CPU, I/O);
UnionFS - тип файловой системы, позволяющий накладывать состояние файловой системы как слои: каждый последующий слой использует предыдущий в режиме Copy-on-write, то есть хранит изменения только от предыдущего слоя. Основные поддерживаемые реализации - aufs, btrfs, overlay2.
Как видно, Docker схож с LXC в используемых технологиях, но цель этих систем разная. Цель LXC - запуск легковесной ОС, в то время как в Docker - запуск конкретного приложения в изолированной среде.

Docker состоит из нескольких компонент - Docker Daemon dockerd и Docker CLI docker. Docker CLI общается с Docker Daemon по REST API для управления всеми ресурсами при помощи небольшого количества команд.

Но перед рассмотрением основных команд разберем основные понятия:

Docker - это инструмент, упрощающий разработку, тестирование и выкладку приложений в контейнерах.
Контейнер - это изолированная среда, в которой осуществляется полезная нагрузка (как правило - какое-то приложение), запущенная из образов.
Образ - это упакованное в архив приложение со всеми требующимися зависимостями - как системными (скажем, библиотеки для работы с БД), так и с зависимостями приложения (Ruby Gems/NodeJS modules/...).
Хостовая система - система, в которой запущен контейнер.
Теперь пройдемся по основным командам, связанным с работой с контейнерами.

run
docker run - данная команда используется для запуска контейнера. Имеет большое количество параметров, которые позволяют определить поведение контейнера: его разрешения, сетевые настройки и другие параметры. Рассмотрим, что означают аргументы и опции, передаваемые в нашем случае:

-d - detach - означает, что нужно запустить контейнер и оставить работать его на фоне. Без этого флага контейнер запускается так, как если бы мы запустили команду вручную - логи утилиты отправляются к нам в консоль, других действий при этом совершать мы не можем, а при закрытии консоли приложение останавливается.
-p 127.0.0.1:28080:80 - данный параметр определяет перенаправление сетевых портов (port mapping), то есть показывает, как мы можем получить доступ к приложению внутри нашего контейнера из хостовой системы так, будто оно было запущено на самой хостовой системе.
Общий синтаксис флага следующий:

-p [[$HOST_LISTEN_ADDRESS:]$HOST_LISTEN_PORT:]$CONTAINER_LISTEN_PORT[/$PROTOCOL]

Где:

HOST_LISTEN_ADDRESS - адрес, на котором должен быть проброшен порт на хосте. По умолчанию - 0.0.0.0, то есть запросы слушаются на всех адресах. Возможные значения: (ip4|ipv6) адрес.
HOST_LISTEN_PORT - порт, на который должен быть проброшен порт на хосте. При отсутствии используют тот же порт, что и в контейнере. Возможные значения: (0 .. 65535).
CONTAINER_LISTEN_PORT - порт, который должен быть проброшен на хост. Возможные значения: (0 .. 65535).
PROTOCOL - протокол, который требуется пробросить. Возможные значения: (udp|tcp).
После подстановки значений (у вас они могут отличаться) флаг будет выглядеть таким образом: -p 192.168.1.100:8080:80/tcp.

--name rbm-dkr-01 - имя контейнера. В случае, если опция не задана, Docker сгенерирует случайное имя.
nginx:stable - имя образа и его тег. Из названия видно, что образ запускает nginx из ветки stable (версии с четной минорной версией). Пока условимся, что у нас есть только такой образ, - в последующих заданиях мы поясним это подробно.
ps
docker ps - это команда, которая выводит список работающих контейнеров, их имена, используемый для запуска образ, порты и прочую информацию, не слишком важную для нас сейчас. По умолчанию команда выводит именно работающие контейнеры, однако с использованием флага -a можно получить список всех контейнеров, которые есть в нашей системе, в том числе и остановленных.

stop
docker stop - это команда, которая используется для остановки.

Действие команды stop похоже на отправку сигнала SIGTERM процессу, то есть она мягко останавливает процесс. Но если в ходе остановки контейнера процесс не реагирует на сигнал SIGTERM, то через 19 секунд Docker отправляет уже безапелляционный сигнал - SIGKILL, который сразу прекращает процесс.

rm
docker rm - эта команда используется для удаления остановленных контейнеров.

Однако важно обратить внимание именно на то, что для удаления контейнера нужно, чтобы контейнер был остановлен. Однако мы также можем использовать флаг --force чтобы насильно удалить контейнер. Без него, если мы попытаемся вызвать команду на работающий контейнер, нам будет указано на необходимость предварительной остановки контейнера, а только потом можно сделать удаление. Как правило, использование docker rm --force сродни использованию git push --force, то есть использование возможно, но только обдуманное.

start
docker start - используется для старта остановленного контейнера.

Важно различать команды run и start - первая используется для запуска нового контейнера, а вторая - для запуска существующего остановленного контейнера.

logs
logs — позволяет вывести логи контейнера в консоль. docker logs — позволяет вывести логи контейнера в консоль.

Как и с другими командами, у команды logs есть свои флаги, которые позволяют решать разные задачи:

-f — подключается к логам и выводит их по мере поступления. Аналогично использованию tail -f по файлу в своей консоли;
--tail N — выводит последние N строк лога (без параметра выводит все, а не 10, как с консольным tail);
--since DATE — позволяет вывести логи, начиная с определенной даты (пример - 2019-09-10) или с дельты (пример - 1h, то есть начиная с часа назад);
-t|--timespamps — позволяет вместе с логами выводить timestamp — временную метку, показывающую, когда эти логи были получены.
Для получения списка всех флагов можно ввести команду docker logs --help.

Интересен механизм сборки логов — вывод в стандартные потоки (stdout, stderr) принимает Docker и сохраняет эти логи. То есть все, что выводит приложение в консоль при ручном запуске, автоматически попадает в логи.

Существуют еще более интересные кейсы по работе с логами. Поскольку контейнер под капотом запускает Linux, то можно немного схитрить при выводе логов в Docker Logs: если приложение не умеет само писать логи в stdout, то можно предложить ему вместо файла логов - ссылки на файлы /dev/stdout или /dev/stderr, которые работают как устройства вывода процесса.

images
Для просмотра образов, которые имеются на хосте, нужно вызвать команду:

docker images - выводит список всех образов, содержащихся на хосте.

Пример вывода:

$ docker images
REPOSITORY       TAG                 IMAGE ID            CREATED             SIZE
nginx            stable-alpine       8587e8f26fc1        2 months ago        21.2MB
Описание колонок:

REPOSITORY — имя образа. Как правило, содержит еще и адрес внешнего реестра (registry), если он отличается от реестра по умолчанию.
TAG — тег образа, который может отображать определенное состояние образа (например, stable или testing), либо ту операционную систему, на базе которой собран образ, либо ту версию приложения, которая содержится в образе.
IMAGE ID — по аналогии с ID контейнеров, каждый образ имеет свой идентификатор, который можно указывать при запуске контейнера.
CREATED — дата, когда образ был создан (то есть, когда он был именно собран, а не скачан).
SIZE — полный размер образа.
Реестр (registry) - удаленное хранилище для образов Docker. По умолчанию используется Docker Hub. Не стоит путать с репозиторием (repository) - это то, что можно назвать именем образа.

Главная сила Docker состоит в том, что вне зависимости от системы, в которой мы хотим запустить приложение, оно должно запускаться одинаково, что позволяет воспроизводить рабочую среду разработчика и на серверах, и на технике других разработчиков. И кроме того, при помощи Docker на дистрибутивах Linux одного семейства можно запускать приложения, которые будут запущены в окружении совершенно другого дистрибутива.

Данных знаний вам должно быть достаточно для того, чтобы запускать и управлять контейнерами в Docker. На этом возможности Docker не заканчиваются, но рассмотрение всех вещей, которые можно сделать при помощи него, сильно выходит за рамки этого практикума.

В рамках практического задания мы и запустим наш первый контейнер, продемонстрировав, как удобно позволяет данная технология запускать нужное нам приложение без установки в системе. В одном из последующих заданий мы воспользуемся этим, чтобы запустить приложение, запуск которого в самом Ubuntu крайне проблематичен.

Полезные ссылки:
Docker
What is Docker
Install docker
Docker Cheat Sheet
В чем разница между Docker, LXD и LXC
Docker run reference (official docs)
