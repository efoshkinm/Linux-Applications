Задание:
Установите веб-сервер nginx (если в вашей системе он еще не установлен).
Создайте новый virtual host, соответствующий следующим требованиям:
слушает только на локальном порту 8880;
пишет access и error логи в файлы /var/log/rotated.access.log и /var/log/rotated.error.log соответственно.
Напишите правило logrotate, соответствующее следующим требованиям:
целью правила должны быть логи, указанные в virtual host;
производить ротацию при объеме файла более 100 килобайт;
держать 3 архивных лога;
первый архивный лог НЕ должен сжиматься;
не ротировать лог, если он пустой;
после ротации отправлять приложению сигнал на переоткрытие лога только один раз для всех файлов.
Напишите скрипт, который отправит 2000 запросов на ваш новый virtual host, для того чтобы сгенерировать необходимый объем логов.
Вручную вызовите logrotate для ротации логов.
Выведите список всех созданных логов вашего virtual host с указанием объемов файлов в человекочитаемом формате.
Повторите запросы для заполнения логов.
Вручную вызовите logrotate для ротации логов
Выведите список всех созданных логов вашего virtual host с указанием объемов файлов в человекочитаемом формате.
На проверку отправьте конфигурационный файл nginx, правило logrotate и все сохраненные команды с их выводами.

****************************************************************************
Решение
****************************************************************************
Ефошкин Максим Вячеславович
ОТПРАВЛЕНО
30.08.2022 21:07
1. Установите веб-сервер nginx (если в вашей системе он еще не установлен).
address: 158.160.2.228
apt update & apt upgrade
sudo apt install nginx-full

2. Создайте новый virtual host, соответствующий следующим требованиям:
root@epdlv1e36q3h3fs0ru5j:/etc/nginx# cat sites-enabled/logrotate_http 
server {
       listen 8880 default_server;
       listen [::]:8880 default_server;
       access_log /var/log/rotated.access.log;
       error_log  /var/log/rotated.error.log;
       server_name 158.160.2.228.nip.io;
       root /var/www/html;
       location / {
  	      index index.nginx-debian.html;
              try_files  $uri $uri/ =404;
       }
}

http://158.160.2.228.nip.io:8880/
3. Напишите правило logrotate, соответствующее следующим требованиям:
vi /etc/logrotate.d/nginx

/var/log/rotated.access.log /var/log/rotated.error.log {
	size = 100K
	rotate 3
	delaycompress
	notifempty
	sharedscripts
	postrotate
            /usr/bin/killall -HUP nginx
   	endscript
}

4. Напишите скрипт, который отправит 2000 запросов на ваш новый virtual host, для того чтобы сгенерировать необходимый объем логов.
root@epdlv1e36q3h3fs0ru5j:/home/yc-user# cat ./script 
for i in $(seq 1 2000);
do
   curl http://158.160.2.228.nip.io:8880/
done
root@epdlv1e36q3h3fs0ru5j:/home/yc-user# 

root@epdlv1e36q3h3fs0ru5j:/home/yc-user# cat /var/log/rotated.access.log  | wc -l
2010
root@epdlv1e36q3h3fs0ru5j:/home/yc-user# 

systemctl restart logrotate

5. Вручную вызовите logrotate для ротации логов.
logrotate /var/log/rotated.access.log

 ll /var/log/rotated.* -h
-rw-r--r-- 1 root root    0 Aug 30 17:38 /var/log/rotated.access.log
-rw-r--r-- 1 root root 178K Aug 30 17:32 /var/log/rotated.access.log.1
-rw-r--r-- 1 root root    0 Aug 30 06:55 /var/log/rotated.error.log


6. Повторный вызов
./script

 ll /var/log/rotated.* -h
-rw-r--r-- 1 root root 176K Aug 30 17:42 /var/log/rotated.access.log
-rw-r--r-- 1 root root 178K Aug 30 17:32 /var/log/rotated.access.log.1
-rw-r--r-- 1 root root    0 Aug 30 06:55 /var/log/rotated.error.log

root@epdlv1e36q3h3fs0ru5j:/home/yc-user# cat /var/log/rotated.access.log | tail
158.160.2.228 - - [30/Aug/2022:17:42:56 +0000] "GET / HTTP/1.1" 200 612 "-" "curl/7.68.0"
158.160.2.228 - - [30/Aug/2022:17:42:56 +0000] "GET / HTTP/1.1" 200 612 "-" "curl/7.68.0"
158.160.2.228 - - [30/Aug/2022:17:42:56 +0000] "GET / HTTP/1.1" 200 612 "-" "curl/7.68.0"
158.160.2.228 - - [30/Aug/2022:17:42:56 +0000] "GET / HTTP/1.1" 200 612 "-" "curl/7.68.0"
158.160.2.228 - - [30/Aug/2022:17:42:56 +0000] "GET / HTTP/1.1" 200 612 "-" "curl/7.68.0"
158.160.2.228 - - [30/Aug/2022:17:42:56 +0000] "GET / HTTP/1.1" 200 612 "-" "curl/7.68.0"
158.160.2.228 - - [30/Aug/2022:17:42:56 +0000] "GET / HTTP/1.1" 200 612 "-" "curl/7.68.0"
158.160.2.228 - - [30/Aug/2022:17:42:56 +0000] "GET / HTTP/1.1" 200 612 "-" "curl/7.68.0"
158.160.2.228 - - [30/Aug/2022:17:42:56 +0000] "GET / HTTP/1.1" 200 612 "-" "curl/7.68.0"
158.160.2.228 - - [30/Aug/2022:17:42:56 +0000] "GET / HTTP/1.1" 200 612 "-" "curl/7.68.0"

Выдает ошибку 
error: /var/log/rotated.access.log:1998 lines must begin with a keyword or a filename (possibly in double quotes)
error: /var/log/rotated.access.log:1999 lines must begin with a keyword or a filename (possibly in double quotes)
error: /var/log/rotated.access.log:2000 lines must begin with a keyword or a filename (possibly in double quotes)
root@epdlv1e36q3h3fs0ru5j:/home/yc-user# systemctl status logrotate
● logrotate.service - Rotate log files
     Loaded: loaded (/lib/systemd/system/logrotate.service; static; vendor preset: enabled)
     Active: inactive (dead) since Tue 2022-08-30 17:38:38 UTC; 9min ago
TriggeredBy: ● logrotate.timer
       Docs: man:logrotate(8)
             man:logrotate.conf(5)
    Process: 20461 ExecStart=/usr/sbin/logrotate /etc/logrotate.conf (code=exited, status=0/SUCCESS)
   Main PID: 20461 (code=exited, status=0/SUCCESS)

Aug 30 17:38:38 epdlv1e36q3h3fs0ru5j systemd[1]: Starting Rotate log files...
Aug 30 17:38:38 epdlv1e36q3h3fs0ru5j systemd[1]: logrotate.service: Succeeded.
Aug 30 17:38:38 epdlv1e36q3h3fs0ru5j systemd[1]: Finished Rotate log files.

systemctl restart logrotate
 logrotate -f /var/log/rotated.access.log 
Получилось после рестарта

 ll /var/log/rotated.* -h
-rw-r--r-- 1 root root    0 Aug 30 17:48 /var/log/rotated.access.log
-rw-r--r-- 1 root root 176K Aug 30 17:42 /var/log/rotated.access.log.1
-rw-r--r-- 1 root root 178K Aug 30 17:32 /var/log/rotated.access.log.2
-rw-r--r-- 1 root root    0 Aug 30 06:55 /var/log/rotated.error.log

10. Вывод конфигов nginx, logrotate
root@epdlv1e36q3h3fs0ru5j:/etc/nginx# cat sites-enabled/logrotate_http 
server {
       listen 8880 default_server;
       listen [::]:8880 default_server;
       access_log /var/log/rotated.access.log;
       error_log  /var/log/rotated.error.log;
       server_name 158.160.2.228.nip.io;
       root /var/www/html;
       location / {
  	      index index.nginx-debian.html;
              try_files  $uri $uri/ =404;
       }
}


root@epdlv1e36q3h3fs0ru5j:/etc# cat logrotate.d/nginx 
/var/log/nginx/*.log {
	daily
	missingok
	rotate 14
	compress
	delaycompress
	notifempty
	create 0640 www-data adm
	sharedscripts
	prerotate
		if [ -d /etc/logrotate.d/httpd-prerotate ]; then \
			run-parts /etc/logrotate.d/httpd-prerotate; \
		fi \
	endscript
	postrotate
		invoke-rc.d nginx rotate >/dev/null 2>&1
	endscript
}

/var/log/rotated.access.log /var/log/rotated.error.log {
	size = 100K
	rotate 3
	delaycompress
	notifempty
	sharedscripts
	postrotate
            /usr/bin/killall -HUP nginx
   	endscript
}


Почемуто в кроне нет logrotate. 
Я так понимаю его нужно руками добавлять?? 
 0 1 * * * /opt/sbin/logrotate -s $HOME/logs/logrotate.state $HOME/etc/logrotate.conf

root@epdlv1e36q3h3fs0ru5j:/etc# cat crontab
# /etc/crontab: system-wide crontab
# Unlike any other crontab you don't have to run the `crontab'
# command to install the new version when you edit this file
# and files in /etc/cron.d. These files also have username fields,
# that none of the other crontabs do.

SHELL=/bin/sh
PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin

# Example of job definition:
# .---------------- minute (0 - 59)
# |  .------------- hour (0 - 23)
# |  |  .---------- day of month (1 - 31)
# |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...
# |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat
# |  |  |  |  |
# *  *  *  *  * user-name command to be executed
17 *	* * *	root    cd / && run-parts --report /etc/cron.hourly
25 6	* * *	root	test -x /usr/sbin/anacron || ( cd / && run-parts --report /etc/cron.daily )
47 6	* * 7	root	test -x /usr/sbin/anacron || ( cd / && run-parts --report /etc/cron.weekly )
52 6	1 * *	root	test -x /usr/sbin/anacron || ( cd / && run-parts --report /etc/cron.monthly )
#
root@epdlv1e36q3h3fs0ru5j:/etc# 

`

ОТВЕТ КУРАТОРА
Oleg Avdeev (@oavdeev)
ВЫПОЛНЕНО 4
31.08.2022 21:15
Добрый день, вижу что скрипт в целом работает, но есть вопросы.

Для чего вот эта секция в конфиге логротейта "/var/log/nginx/*.log ", ваши логи в другом каталоге. Впрочем видимо это стандартная секция и нашему запуску она не мешает.
по поводу ошибок при ротировании, надо посмотреть что в строках файла 1998-2000
почему у вас логи не сжимаются ?
Я так понимаю его нужно руками добавлять??

Существуют разные варианты запуска, например через /etc/cron.daily/logrotate, но в вашей системе запуск видимо происходит не через cron, а через systemd.timer.

06.09.2022 09:43
ВЫПОЛНЕНО 5
Ефошкин Максим Вячеславович
ОТПРАВЛЕНО
06.09.2022 09:43
1. Установка
address: 130.193.53.114
apt update & apt upgrade
sudo apt install nginx-full

root@epdavvtit50vgk6hbnkn:/etc/nginx/sites-enabled# cat logrotate 
server {
       listen 8880 default_server;
       listen [::]:8880 default_server;
       access_log /var/log/rotated.access.log;
       error_log  /var/log/rotated.error.log;
       server_name 130.193.53.114.nip.io;
       root /var/www/html;
       location / {
  	      index index.nginx-debian.html;
              try_files  $uri $uri/ =404;
       }
}
root@epdavvtit50vgk6hbnkn:/etc/nginx/sites-enabled# 
systemctl restart nginx


Logrotate rules:
vi /etc/logrotate.d/nginx
root@epdavvtit50vgk6hbnkn:/var/log# cat /etc/logrotate.d/nginx 
/var/log/rotated.access.log 
/var/log/rotated.error.log 
{
	size = 100K
	rotate 3
 	compress
	delaycompress
	notifempty
	sharedscripts
	postrotate
            /usr/bin/killall -HUP nginx
   	endscript
}
root@epdavvtit50vgk6hbnkn:/var/log# 
systemctl restart logrotate

script:
root@epdavvtit50vgk6hbnkn:/opt/logrotate# cat /opt/logrotate/script 
for i in $(seq 1 2000);
do
   curl http://130.193.53.114.nip.io:8880/
done
root@epdavvtit50vgk6hbnkn:/opt/logrotate# 

Запуск скрипта
./script

Проверяем
root@epdavvtit50vgk6hbnkn:/var/log# ll rotated.* -h
-rw-r--r-- 1 root root 179K Sep  6 06:21 rotated.access.log
-rw-r--r-- 1 root root    0 Sep  6 06:20 rotated.error.log
root@epdavvtit50vgk6hbnkn:/var/log#

Вызываем повторно скрипт:
/opt/logrotate/script
root@epdavvtit50vgk6hbnkn:/var/log# ll rotated.* -h
-rw-r--r-- 1 root root 178K Sep  6 06:38 rotated.access.log
-rw-r--r-- 1 root root 179K Sep  6 06:21 rotated.access.log.1
-rw-r--r-- 1 root root    0 Sep  6 06:20 rotated.error.log
root@epdavvtit50vgk6hbnkn:/var/log# 

Вызываем логротейт:

root@epdavvtit50vgk6hbnkn:/var/log# systemctl restart logrotate
root@epdavvtit50vgk6hbnkn:/var/log# logrotate /var/log/rotated.access.log 
root@epdavvtit50vgk6hbnkn:/var/log# ll rotated.* -h
-rw-r--r-- 1 root root    0 Sep  6 06:40 rotated.access.log
-rw-r--r-- 1 root root 178K Sep  6 06:38 rotated.access.log.1
-rw-r--r-- 1 root root 1.1K Sep  6 06:21 rotated.access.log.2.gz
-rw-r--r-- 1 root root    0 Sep  6 06:20 rotated.error.log
root@epdavvtit50vgk6hbnkn:/var/log# 




ОТВЕТ КУРАТОРА
Oleg Avdeev (@oavdeev)
ВЫПОЛНЕНО 5
07.09.2022 09:42
Максим, здравствуйте! Похоже всё правильно, вопросов и замечаний больше нет.



*****************************************************************************
Теория
*****************************************************************************

LNXA-06 01: Logging. logrotate
Описание:
В этом модуле мы разберем такую важную вещь, как журналирование. Важна эта тема тем, что часто именно журнал выполнения (для краткости далее будем пользоваться термином логи, производным от английского слова logs) является источником информации о проблемах в вашей системе, выступая в роли своебразного чёрного ящика. В первом приближении с этой темой мы с вами уже знакомились тем или иным образом. Начиная с этого задания, мы разберем основные инструменты для работы с логами в очередности их появления и в зависимости от назначения.

Начнем с давних времен — когда логи писались очень аккуратно из-за того, что они реально печатались на бумаге. Свойственно это было тем временам, когда компьютеры были размерами в несколько этажей, работали на теплых лампах и складывали 2 числа с немыслимым временем выполнения в миллисекунды! В те времена общение с компьютером прозводилось совершенно другим путем — на вход подавались перфокарты (картонка с набитыми отверстиями) с программой в двоичном коде, а на выходе спустя пару часов мы могли получить результат выполнения. Или провала. Часто — именно провала. И благодаря этому выводу, нужно было понять, что пошло не так, где вы были неправы и на которой из десяток картонок вы неправильно пробили отверстие. Логи в данном случае не хранились в компьютере, а выдавались напрямую, но уже тогда начались проблемы, что бумага-то занимает место. Вот ее и выбрасывали, использовали как черновики для других задач или как средство розжига печи.

Но время шло, компьютеры становились меньше, появлялись новые средства ввода-вывода данных, начали появляться постоянные хранилища для компьютеров, которые стали эволюционировать и дешеветь. Хотя этот процесс помог снизить затраты бумажной продукции впустую, появилась другая проблема — сохраненные выходы теперь занимают место не на полу, а на постоянном хранилище, постепенно уменьшая полезное пустое пространство для работы програм до тех пор, пока не остается ни процента свободного места.

Бороться с этим можно разными путями:

Ждать, пока место закончится и вручную подчищать логи для освобождения места — в случае, если система не критична или запускается временно, этот метод применим, но опасен в долгосрочной перспективе, поскольку может «выстрелить в ногу».
Следить за объемом свободного или используемого логами места автоматизированными средствами и при срабатывании подчищать логи — шаг в правильную сторону, но все еще не исключает вероятности «выстрела» при промедлении реакции на событие.
Настроить периодическую задачу для очистки логов (к примеру, при помощи cron) — довольно неплохой вариант, который доступен почти в любой Unix-системе, но когда встает вопрос о логике сложнее «удали все файлы, кроме текущего», выполняемый скрипт начинает обрастать костылями или скопированным кодом, что может привести к неожиданным последствиям.
Использовать автоматизированное решение, которое заточено под задачи работы с логами и делает это хорошо.
Именно последний инструмент мы разберем в этом задании. Имя ему — logrotate, это утилита, призванная решить большинство задач по работе с логами в файловой системе, будь то простое удаление старых логов или сжатие файлов с уведомлением о чистке файлов и оповещением сервиса о проделанной чистке.

Основной конфигурационный файл logrotate находится в /etc/logrotate.conf. Начнем с того, что разберем его, чтобы ориентироваться в формате:

# see "man logrotate" for details
# rotate log files weekly
weekly

# use the syslog group by default, since this is the owning group
# of /var/log/syslog.
su root syslog

# keep 4 weeks worth of backlogs
rotate 4

# create new (empty) log files after rotating old ones
create

# uncomment this if you want your log files compressed
#compress

# packages drop log rotation information into this directory
include /etc/logrotate.d

# no packages own wtmp, or btmp -- we'll rotate them here
/var/log/wtmp {
    missingok
    monthly
    create 0664 root utmp
    rotate 1
}

/var/log/btmp {
    missingok
    monthly
    create 0660 root utmp
    rotate 1
}

# system-specific logs may be configured here
Этот конфигурационный файл используется для установки глобальных настроек, таких как — от какого пользователя должна производиться ротация логов, сколько отротированных логов требуется хранить и как часто их ротировать. Кроме того, здесь приведена конфигурация для двух файлов — /var/log/btmp и /var/log/wtmp (они хранят информацию о входах в систему, ее можно просмотреть такими утилитами, как lastlog), которые можно использовать как основу для своих файлов. Как видно, формат следующий:

ФАЙЛЫ_К_КОТОРЫМ_ПРИМЕНЯЮТСЯ_ПРАВИЛА_РОТАЦИИ {
  ПРАВИЛА_РОТАЦИИ
  ...
}
Имя целевых файлов можно задать несколькими методами:

Прямое задание имени одного файла — удобно в случае, если требуется ротация для одного конкретного файла (пример - /var/log/logfile).
Прямое задание имени нескольких файлов — аналогично первому, но в случае, если у вас несколько файлов подходят под одно правило, где разделителем имен файлов выступает пробел. Пример — "/var/log/error log" /var/log/logfile — заметим, что первый лог выделен двойными кавычками для того, чтобы указать верно имя файла с пробелом — это Wildcard формат. Это удобно, когда ваше приложение выдает несколько логов либо в одну директорию, либо с каким-то суффиксом иил префиксом (пример — /var/log/app/*.log).
Правила ротации, связанные с конкретными файлами имеют бОльший приоритет, чем глобальные параметры. То есть, к примеру, если вы указали для своего файла ежедневную ротацию файлов, то logrotate будет использовтаь именно это правило, а не глобальное (в нашем случае — еженедельная ротация). В ином случае — ваши правила унаследуют глобальные.

Разберем правила ротации, которые можно применять в конфигурации logrotate:

compress — указывает, что требуется производить сжатие старых файлов (для сжатия используется утилита gzip по умолчанию, но возможно поменять утилиту при помощи правила compresscmd). Если же мы НЕ хотим сжимать отротированные файлы, можно использовать директиву nocompress.
compressext — определяет, какое расширение требуется добавить к файлам после сжатия.
compressoptions — определяет, какие параметры требуется передать утилите сжатия.
delaycompress — указывает, что сжимать первый ротированный лог НЕ нужно (а вот второй и далее — сжимаются). Бывает полезно, если требуется быстрый доступ к предыдущему логу без использования утилит разархивации.
extension — задает, какой суффикс будет добавлен к ротированным логам (в случае использования сжатия суффикс сжатия добавляется сразу после указанного расширения) (пример — extension rotated, тогда ротированные логи будут выглядить как log.rotated.0 и log.rotated.1, а сжатый — log.2.rotated.gz).
create — определяет, что после ротации файла (но перед запуском postrotate) требуется создать новый файл с указанными правами доступа, его владельцем является конкретный пользователь и группа (пример — create 664 www-data www-data). В случае, если создание новых файлов НЕ требуется, можно использовать директиву nocreate.
copy — ротированный файл будет представлять собой копию текущего файла. Может использоваться, если за очистку лога отвечает другая утилита (можно выключить это поведение директивой nocopy).
copytruncate — производит копию файла и очищает текущий файл (почти так, как если бы вы сделали echo > $TARGET_FILE). Бывает полезно, если приложение НЕ умеет переоткрывать файл для логирования без остановки приложения (о возможной проблеме поговорим позднее) (можно выключить это поведение директивой nocopytruncate).
dateext — указывает, что к ротированным файлам требуется добавлять окончание с датой, формат которой задается в директиве dateformat (используется тот же формат, что и у каманды date, по умолчанию используется -%Y%m%d).
daily — определяет, что ротацию логов требуется производить ежедневно.
weekly — производить ротацию раз в неделю.
monthly — производить ротацию ежемесячно в конце месяца.
yearly — производить ротацию раз в год в то же время, когда была предыдущая ротация.
include — указывает, из какого файла/директории подключить дополнительные правила обработки логов
mail — оповещать по указанной почте о том, что отротированный файл был удален при превышении количества ротируемых файлов (это логика по умолчанию, как если бы была установлена директива maillast), или об имени только отротированного файла (возможно через добавление директивы mailfirst) (требует конфигурации почтового агента на хосте). Если же отправка письма не требуется, можно воспользоваться директивой nomail.
ifempty — производить ротацию, даже если файл пустой (обратная директива - notifempty).
missingok — если целевой файл отсутствует, не вызывать ошибку (по умолчанию выставлена директива nomissingok, которая реагирует на отсутствие логов ошибкой).
maxage — указывает, через сколько дней хранения отротированные логи должны быть удалены (может быть актуально, если логи пишутся небыстро и хранение не имеет смысла) (пример — maxage 7).
minsize — указывает, какого минимального объема должен быть лог, чтобы logrotate произвел ротацию файла по указанному правилу (скажем, если ротация производится еженедельно, то будет ожидаться необходимый день ротации, чтобы произвести проверку объема файла). Размер указывается в байтах.
olddir — указывает, в какой директории должны храниться старые логи (переопределение этой опции возможно при помощи noolddir).
size — определяет, при превышении какого объема требуется ротировать файл (можно использовать приставки k,M,G для указания, что объем файла в кило-, мега- или гигабайтах).
start — определяет, с какого числа начинать нумеровать ротированные логи (по умолчанию - 0).
rotate — определяет, сколько ротированных логов требуется оставить.
prerotate/endscript — определяет, какой скрипт должен быть запущен до ротации лога. Важно то, что скрипт должен быть расположен в строке между prerotate и endscript.
postrotate/endscript — аналогично, но действие производится после ротации лога.
firstaction/endscript — определяет, какой скрипт должен быть разово запущен перед ротацией файлов, указанных через wildcard.
lastaction/endscript — аналогично, но действие производится после ротации логов, попадающих под wildcard.
sharedscripts — указывает, что скрипты из prerotate и postrotate должны запускаться только один раз в случае, если было отротировано более одного файла (возможно отметить данный скрипт при помощи директивы nosharedscripts).
Директива copytruncate позволяет избежать случая, когда мы удалили лог, в который писало приложение, и создали новый. Это может привести к тому, что новые логи не будут писаться в новый файл, а свободное место в системе будет уменьшаться из-за того, что приложение продолжает писать в файловый дискриптор, с которым оно начало работать при старте, а значит, откроет новый файл только при перезапуске (повторимся — это в случае, если приложение не умеет переоткрывать файл без перезапуска).

Последний вопрос, который может возникнуть при изучении logrotate, — как он запускается? Как и другие автоматизированные вещи, logrotate запускается при помощи cron, в чем можно убедиться по содержимому файла /etc/cron.daily/logrotate (из директории легко понять, что logrotate запускается ежедневно).

Полезные ссылки:
logrotate(8) — Linux man page
Автоматическая ротация log'ов с помощью logrotate (log rotate linux)
Установка Logrotate для управления логами в Unix/Linux
