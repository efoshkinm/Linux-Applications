Задание:
Настройте ваш удаленный виртуальный сервер на принятие логов на TCP порте 5514 и записи только логов из facility local2 в файл /var/log/remote.
Настройте вашу локальную виртуальную машину на отправку всех логов facility local2 на ваш удаленный виртуальный сервер и в файл /var/log/local2.
При помощи утилиты logger на локальной виртуальной машине отправьте сообщение Rsyslog test как local2.emerg (команду и вывод сохраните).
Выведите на удаленном виртуальном сервере содержимое файла /var/log/remote — в нем должно содержаться отправленное сообщение (команду и вывод сохраните).
На проверку отправьте конфигурационный файл с локальной виртуальной машины, удаленного виртуального сервера и сохраненные выводы из консоли.

****************************************************************************
Решение
****************************************************************************
Ефошкин Максим Вячеславович
ОТПРАВЛЕНО
13.09.2022 09:23
1. Установка
address: 84.252.138.247

2. Настройте ваш удаленный виртуальный сервер на принятие логов на TCP порте 5514 и записи только логов из facility local2 в файл /var/log/remote.
vi /etc/rsyslog.conf
# Добавил в конце
module(load="omfile")
module(load="builtin:omfile" Template="RSYSLOG_TraditionalFileFormat")
ruleset(name="remote"){
        if prifilt("local2.*") then {
        action(type="omfile" file="/var/log/remote")
                stop
        }
}
module(load="imtcp" MaxSessions="500")
input(type="imtcp" port="5514" ruleset="remote")

systemctl restart rsyslog.service
root@epd2ensuuj1c944sck4o:/etc# ss -lntp
State       Recv-Q       Send-Q             Local Address:Port             Peer Address:Port      Process                                                                                           
LISTEN      0            4096               127.0.0.53%lo:53                    0.0.0.0:*          users:(("systemd-resolve",pid=381,fd=13))                                                        
LISTEN      0            128                      0.0.0.0:22                    0.0.0.0:*          users:(("sshd",pid=585,fd=3))                                                                    
LISTEN      0            55                       0.0.0.0:5514                  0.0.0.0:*          users:(("rsyslogd",pid=1719,fd=6))                                                               
LISTEN      0            128                         [::]:22                       [::]:*          users:(("sshd",pid=585,fd=4))                                                                    
LISTEN      0            55                          [::]:5514                     [::]:*          users:(("rsyslogd",pid=1719,fd=7))                                                               
root@epd2ensuuj1c944sck4o:/etc# 

3. Настройте вашу локальную виртуальную машину на отправку всех логов facility local2 на ваш удаленный виртуальный сервер и в файл /var/log/local2.
vi /etc/rsyslog.conf
# Добавил 

module(load="omfwd")
module(load="omfile")

local2.* {
        action(type="omfile" file="/var/log/local2")
        action(type="omfwd" target="84.252.138.247" port="5514" protocol="tcp")
}

systemctl restart rsyslog.service

4. При помощи утилиты logger на локальной виртуальной машине отправьте сообщение Rsyslog test как local2.emerg (команду и вывод сохраните).
[root@MiWiFi-R4A-srv m.efoshkin]# logger -p local2.emerg Hello World
[root@MiWiFi-R4A-srv m.efoshkin]# logger -p local2.emerg Rsyslog test

[root@MiWiFi-R4A-srv m.efoshkin]# cat /var/log/local2 
Sep 13 09:06:32 MiWiFi-R4A-srv m.efoshkin[17351]: Hello World
Sep 13 09:10:25 MiWiFi-R4A-srv root[17604]: Rsyslog test
[root@MiWiFi-R4A-srv m.efoshkin]# 

# Мне нужно было разрешить SELinux
cat messages
sealert -l 921a6556-baa7-412f-b90b-cb0ed2c82c58
ausearch -c 'rs:main Q:Reg' --raw | audit2allow -M my-rsmainQReg
semodule -i my-rsmainQReg.pp

5. Выведите на удаленном виртуальном сервере содержимое файла /var/log/remote — в нем должно содержаться отправленное сообщение (команду и вывод сохраните).
# Мне нужно было разр
root@epd2ensuuj1c944sck4o:/var/log# cat remote 
Sep 13 09:20:32 MiWiFi-R4A-srv root[47862]: Rsyslog test
root@epd2ensuuj1c944sck4o:/var/log# 

ОТВЕТ КУРАТОРА
Алексей Кузнецов (@Hystrix)
ВЫПОЛНЕНО 5
13.09.2022 20:45
Добрый день!

Отличные знание темы и выполнение задания, замечаний и вопросов нет!



*****************************************************************************
Теория
*****************************************************************************


LNXA-06 03: Logging. Rsyslogd
Описание:
Продолжая тему syslog, мы рассмотрим наиболее распространенную реализацию демона syslogd - rsyslogd, которая, как вы уже могли заметить, поставляется по умолчанию в актуальные версии дистрибутива Ubuntu.

Rsyslog расшифровывается как [r]ocket-fast [sys]tem for [log] processing, где упор делается на rocket-fast — за счет курса проекта на высокую производительность и модульность решения. Это позволяет строить максимально производительное решение под ваши конкретные нужды, не подключая то, что вам не требуется.

Имеющиеся модули rsyslog позволяют использовать практически любой источник и перенаправлять поток логов почти в любую систему хранения, включая другой rsyslog, создавая своеобразный каскад хранилищ (к примеру, хранить логи на хосте и отправлять логи на удаленный сервер для централизованного хранилища).

Так, в rsyslog существует модуль imjournal, который позволяет получать логи из journald, однако тот же imuxsock, который и используется по умолчанию, также умеет получать логи из journald по сокету, узнавая у systemd, к какому сокету необходимо подключаться (и согласно документации этот метод производительнее первого).

Эта имплементация демона по умолчанию включена в состав дистрибутивов Ubuntu, поэтому устанавливать ее не нужно, но конфигурацию мы будем с вами разбирать в этом задании.

Конфигурация rsyslog хранится в файле /etc/rsyslog.conf, в которой могут быть подключены другие файлы по маске /etc/rsyslog.d/*.conf. Рассмотрим формат конфига на примере стандартного файла конфигурации:

# egrep -v "(^#.*|^$)" /etc/rsyslog.conf
module(load="imuxsock") # provides support for local system logging
module(load="imklog" permitnonkernelfacility="on")
$ActionFileDefaultTemplate RSYSLOG_TraditionalFileFormat
$RepeatedMsgReduction on
$FileOwner syslog
$FileGroup adm
$FileCreateMode 0640
$DirCreateMode 0755
$Umask 0022
$PrivDropToUser syslog
$PrivDropToGroup syslog
$WorkDirectory /var/spool/rsyslog
$IncludeConfig /etc/rsyslog.d/*.conf
Из него видно 2 формата директив — с использованием $ перед директивой и в формате, больше напоминающем программирование. Эти форматы называются legacy и advanced, соответственно (в документации он еще фигурирует как RainerScript). Последний вариант появился позднее и не поддерживается всеми модулями, поэтому в файлах перекликаются разные форматы. Так, директива module в формате advanced может быть записана и в старом формате при помощи директивы $ModLoad.

Однако такой метод требует использовать отдельные директивы для указания параметров подключения модулей. Так, директива module(load="imklog" permitnonkernelfacility="on") превратилась бы в 2 директивы:

$ModLoad imklog
$KLogPermitNonKernelFacility on
Как можно из этого понять, у каждого модуля есть свои параметры, которые хорошо описаны в документации, причем как в новом, так и в старом формате.

Строго говоря, конфигурационный файл rsyslog принято делить на 3 раздела (это хорошо видно в файле без удаления комментариев — можете проверить на своем сервере):

modules — содержит подключение модулей;
global directives — содержит глобальные параметры rsyslog (как раз все директивы с $ выше);
rules — содержит директивы того, как обрабатываются логи.
По факту, последний рездел — самая главная часть, так как описывает основную логику работы — откуда берутся логи, как они обрабатываются и куда отправляются. В связи с этим можно разделить все модули на 3 задачи — input (точка входа логов, имена модулей этой группы начинаются с префикса im — от сокращения input module), output (занимаются отправкой логов, имена начинаются с om) и modify (описывают, как обрабатывать логи, имена начинаются с mm).

Как вы, наверное, уже догадались, использование input модулей вы уже видели — они описываются в начале конфигурационного файла выше — один из них занимается сбором логов из unix socket (по факту — из Journald), второй — из сообщений ядра. Чуть далее мы рассмотрим еще один модуль, нужный для получения логов по сети.

Как несложно догадаться, последние правила принято сохранять именно в путях, попадающих под маску /etc/rsyslog.d/*.conf. Приведем пример одного из таких логов:

# egrep -v "(^#.*|^$)" /etc/rsyslog.d/50-default.conf
auth,authpriv.*	        /var/log/auth.log
*.*;auth,authpriv.none	        -/var/log/syslog
kern.*		                        -/var/log/kern.log
mail.*		                        -/var/log/mail.log
mail.err		                /var/log/mail.err
*.emerg		                :omusrmsg:*
По этим правилам видно, что в них содержатся связки facility.severity с вариациями объединений. Разберем кейсы:

mail.err — захватывает все сообщения от facility mail с уровнем severity err;
kern.* — захватывает все сообщения, у которых в facility указан kern;
*.emerg — захватывает все сообщения, у которых уровень severity — emerg;
auth,authpriv.* — можно записать как 2 директивы auth.* и authpriv.*, что означает отправку всех логов, попадающих под facility auth ИЛИ authpriv;
*.*;auth,authpriv.none — захватывает сообщения из всех facility с любым уровнем severity, за исключением логов, попадающих под правило auth,authpriv.none.
Напротив правила указывается то, куда должны записываться логи. Здесь как раз и определяется использование output модулей.

Как вы видите, большинство логов отправляется в файлы, но в последнем присутствует другой формат цели — :omusrmsg:*. Этот формат означает, что для вывода лога требуется использовать модуль omusrmsg, который производит его вывод в терминал пользователя. Это означает, что если возникает событие такого уровня, оно будет отправлено в терминал пользователя. А вот какого пользователя — задается в первом поле после двоеточия как первый по очередности параметр. В нашем случае пользователем указан *, что означает отправлять логи всем пользователям.

Этот метод записи попадает под формат записи legacy, поскольку берет свои корни из оригинальной реализации syslogd. Однако эти же правила можно записать и в advanced методе, который сложнее с точки написания, но проще с точки зрения понимания логики. Пример конфигурации в этом формате:

auth,authpriv.* {
	action(type="omfile" file="/var/log/auth.log")
}
Из этого формата видно, что мы можем производить несколько действий за раз для каждого типа логов либо отправлять их разными модулями. Для этого просто требуется добавить новое действие в следующей строке. Пример:

auth,authpriv.* {
	action(type="omfile" file="/var/log/auth.log")
	action(type="omfwd" target="remote")
}
Второе действие отправляет логи на удаленный сервер remote. Получается, что все логи, полученные для facility auth или authpriv, будут сохраняться в локальный лог и заодно отправляться на удаленный сервер.

Раз уж мы заговорили о удаленном сервере, то давайте разберемся, как нам настроить его. Как несложно догадаться, для этого нам нужно использовать input модуль. Для принятия сообщений в формате syslog существует 2 модуля — imtcp и imudp, которые определяют, по какому протоколу принимать сообщения. Так, если мы решили принимать сообщения по протоколу TCP, нужно сделать 2 вещи:

module(load="imtcp" MaxSessions="500") # подключить модуль и задать необходимые параметры
input(type="imtcp" port="514") # запустить прослушивание подключений на необходимом порте
При таком формате записи все входящие сообщения проходят по общим правилам системы. Однако, если требуется разделить логику работы с разными источниками, то можно создать несколько правил обработки (ruleset) и таким образом разбить логику обработки.

Если вы описываете правила без явного указания имени ruleset, то они попадают под ruleset по умолчанию (так называемый RSYSLOG_DefaultRuleset). Создание явного ruleset производится следующим образом:

ruleset(name="remote"){
    action(type="omfile" file="/var/log/remote")
}
Если требуется ограничить список связок facility/severity, то можно использовать фильтры в виде if/else внутри ruleset. Так, если мы хотим сохранять только логи из facility auth, а остальное отбрасывать, то ruleset будет иметь следующий вид:

ruleset(name="remote"){
	if prifilt("auth.*") then {
    	action(type="omfile" file="/var/log/remote")
		stop
	}
}
prifilt — это функция, позволяющая выдернуть из приходящего сообщения связку facility/severity, на базе которой можно производить фильтрацию.

Использование этого ruleset выглядит следующим образом:

input(type="imtcp" port="514" ruleset="remote")
Для проверки валидности конфигурационного файла можно вызвать команду rsyslogd -N1 — она выведет ошибки, если таковые имеются.

Хотелось бы упомянуть про одну утилиту отладки rsyslog под названием logger, которая позволяет отправлять логи в ручном режиме. Базовый формат использования — logger -p FACILITY.SEVERITY MESSAGE, однако утилита имеет и другие параметры, позволяющие отправлять логи на удаленные сервера или, к примеру, отправлять логи из файла.

Полезные ссылки:
The rocket-fast Syslog Server (official site)
rsyslog (archlinux wiki)
Rsyslog docs
Логи в Linux часть 1. rsyslog, journald и logrotate
Converting older formats to advanced (official docs)
Cбор логов с rsyslog, именами файлов в тегах, многострочными сообщениями и отказоустойчивостью
systemd/Journal (archlinux wiki)
