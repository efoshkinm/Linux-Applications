LNXA-01 01: Web. nginx. Basics
Описание:
Интернет - это глобальная сеть, через которую можно получить огромное количество данных, начиная от видеопотока с вашими друзьям и родственниками, заканчивая корпоративными данными с вашего места работы. Наиболее распространенным окном в Интернет является браузер, через который отрисовывывается вся эта информация. Однако если то, как пользоваться браузером, сейчас понятно почти каждому, то какое приложение отдает нам контент из интернета - более широкая тема. В рамках этого и последующих блоков мы будем разбирать инфраструктурные компоненты один за одним, чтобы у вас сформировалось как понимание, так и опыт работы с ними.

Начнем мы с web-серверов - тех серверов, которые и обрабатывают бОльшую часть запросов на первой линии, либо выполняя работу сами (к примеру, отдача картинок), либо передавая запросы другим компонентам (например, самописные приложения или прочие внутренние сервисы).

Начнем мы этот блок с одного из самых распространенных веб-серверов - nginx.

Данный инструмент, разработанный Сысоевым Игорем Владимировичем, на самом деле, является намного более, чем просто web-сервером, который способен отдавать только данный ему контент (хотя с этим он справляется прекрасно), но также способен перенаправлять запросы на другие сервисы (которые, к примеру, могут находиться в защищенном сегменте сети вашей компании), включая протоколы HTTP, SMTP, IMAP, POP3. При особом желании nginx можно использовать и как прокси для любых других UDP и TCP протоколов. За счет этого частыми случаями использования nginx являются:

пограничная точка входа из интернета во внутреннюю сеть;
терминирование SSL трафика;
проксирование запросов по другим приложениям;
изменение трафика (к примеру, добавление/удаление HTTP заголовков);
балансировщик нагрузки.
Как правило, конфигурационные файлы nginx расположены в директории /etc/nginx/, где главным файлом является /etc/nginx/nginx.conf. Приведем пример базового конфигурационного файла nginx:

user www-data;
worker_processes auto;
pid /run/nginx.pid;
include /etc/nginx/modules-enabled/*.conf;

events {
	worker_connections 768;
	# multi_accept on;
}

http {

	##
	# Basic Settings
	##

	sendfile on;
	tcp_nopush on;
	tcp_nodelay on;
	keepalive_timeout 65;
	types_hash_max_size 2048;
	# server_tokens off;

	# server_names_hash_bucket_size 64;
	# server_name_in_redirect off;

	include /etc/nginx/mime.types;
	default_type application/octet-stream;

	##
	# SSL Settings
	##

	ssl_protocols TLSv1 TLSv1.1 TLSv1.2; # Dropping SSLv3, ref: POODLE
	ssl_prefer_server_ciphers on;

	##
	# Logging Settings
	##

	access_log /var/log/nginx/access.log;
	error_log /var/log/nginx/error.log;

	##
	# Gzip Settings
	##

	gzip on;

	# gzip_vary on;
	# gzip_proxied any;
	# gzip_comp_level 6;
	# gzip_buffers 16 8k;
	# gzip_http_version 1.1;
	# gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript;

	##
	# Virtual Host Configs
	##

	include /etc/nginx/conf.d/*.conf;
	include /etc/nginx/sites-enabled/*;
}


#mail {
#	# See sample authentication script at:
#	# http://wiki.nginx.org/ImapAuthenticateWithApachePhpScript
#
#	# auth_http localhost/auth.php;
#	# pop3_capabilities "TOP" "USER";
#	# imap_capabilities "IMAP4rev1" "UIDPLUS";
#
#	server {
#	        listen     localhost:110;
#	        protocol   pop3;
#	        proxy      on;
#	}
#
#	server {
#	        listen     localhost:143;
#	        protocol   imap;
#	        proxy      on;
#	}
#}
Каждая строка в данном файле является директивой, определяющей логику работы. Кроме простых директив, которые отделяются друг от друга символом ;, существуют и блоки директив, которые могут располагаться лишь в конкретном отношении друг к другу. Некоторые блоки могут повторяться, некоторые же могут встречаться лишь один раз. В первом приближении уровни конфигурационного файла выглядят следующим образом:

.
└── main
    ├── events
    ├── http
    │   ├── server
    │   │   └── location
    │   └── server
    │       └── location
    └── mail
        ├── server
        └── server
Где уровень main - это основной, включающий такие директивы, как user, pid и другие.

nginx является модульным приложением. Это значит, что каждая из директив в конфиге связана с определенным модулем. Так, к примеру, модуль ngx_core_module отвечает за основную логику web-сервера - то есть определяет как раз те директивы, без которых сервер бы просто не запустился (к примеру, упомянутый user).

Модули существуют двух видов - статические и динамические. Статические - это те модули, которые входят в состав nginx в результате сборки nginx из исходных кодов с добавлением кода необходимого модуля. Динамические же - это модули, которые можно подключать к nginx без сборки самого nginx, хотя сам модуль приходится собирать во внешнюю библиотеку (если, конечно, его нет в виде уже собранного пакета). Однако, увы, nginx не позволяет подключить динамический модуль, если в ходе сборки самого nginx мы не указали в параметрах сборки поддержку конкретного динамического модуля. Иначе говоря - если вам требуется конкретный модуль, то вам в любом случае необходимо собирать nginx из исходных файлов. А вот как - уже на ваше усмотрение и исходя из возможностей работы модуля (не все модули, к примеру, умеют работать как динамические).

Для получения информации о вашей версии nginx, сборке и модулях используется флаг -V при вызове nginx:

# nginx -V
nginx version: nginx/1.14.0 (Ubuntu)
built with OpenSSL 1.1.1  11 Sep 2018
TLS SNI support enabled
configure arguments: --with-cc-opt='-g -O2 -fdebug-prefix-map=/build/nginx-GkiujU/nginx-1.14.0=. -fstack-protector-strong -Wformat -Werror=format-security -fPIC -Wdate-time -D_FORTIFY_SOURCE=2' --with-ld-opt='-Wl,-Bsymbolic-functions -Wl,-z,relro -Wl,-z,now -fPIC' --prefix=/usr/share/nginx --conf-path=/etc/nginx/nginx.conf --http-log-path=/var/log/nginx/access.log --error-log-path=/var/log/nginx/error.log --lock-path=/var/lock/nginx.lock --pid-path=/run/nginx.pid --modules-path=/usr/lib/nginx/modules --http-client-body-temp-path=/var/lib/nginx/body --http-fastcgi-temp-path=/var/lib/nginx/fastcgi --http-proxy-temp-path=/var/lib/nginx/proxy --http-scgi-temp-path=/var/lib/nginx/scgi --http-uwsgi-temp-path=/var/lib/nginx/uwsgi --with-debug --with-pcre-jit --with-http_ssl_module --with-http_stub_status_module --with-http_realip_module --with-http_auth_request_module --with-http_v2_module --with-http_dav_module --with-http_slice_module --with-threads --with-http_addition_module --with-http_geoip_module=dynamic --with-http_gunzip_module --with-http_gzip_static_module --with-http_image_filter_module=dynamic --with-http_sub_module --with-http_xslt_module=dynamic --with-stream=dynamic --with-stream_ssl_module --with-mail=dynamic --with-mail_ssl_module
Из данного вывода можно понять, что на сервере - nginx версии 1.14.0, который использует по умолчанию конфигурационный файл из /etc/nginx/nginx.conf и, к примеру, собран с модулем для работы с gzip, а также использует подключенный к нему модуль для работы с протоколом SMTP (mail).

Подключение динамического модуля производится через директиву load_module в секции main. Соответственно, если мы не используем данный модуль, мы можем просто не загружать его, убрав соответствующиую директиву.

Перед тем, как разбирать основные директивы, уточним, что в конфигурационном файле существует несколько основных правил:

Все директивы должны заканчиваться символом ;.
Блоки директив (тот же http) НЕ заканчиваются ;.
Для комментирования строки используется #.
У каждой директивы есть свой разрешенный контекст (этот пункт мы разъясним далее, после примера конфигурационного файла).
Далее мы будем разбирать основные директивы, с которыми приходится работать чаще всего:

include
Директива include позволяет подключать другие файлы вместо директивы. Выглядит это так, что в ходе запуска сервиса nginx компилирует конфигурационный файл, вставляя вместо этой директивы содержимое тех файлов, которые подключаются, и применяет директивы одну за одной (поэтому последовательность директив важна).

Важно то, что в ходе такого подключения с использованием * подключение файлов производится в алфавитном порядке, поэтому, если вам нужно какой-то конфигурационный файл поставить первым для выполнения, его можно назвать с использованием числа первым символом имени файла (например: 10-base.conf, 20-addition.conf)

В нашем примере эта директива используется в 2 секциях - main (3 строка) для подключения динамических модулей и http. Так, к примеру, подключаемый файл может выглядеть следующим образом:

server {
	listen 80 default_server;
	listen [::]:80 default_server;

	# SSL configuration
	#
	# listen 443 ssl default_server;
	# listen [::]:443 ssl default_server;
	#
	# Note: You should disable gzip for SSL traffic.
	# See: https://bugs.debian.org/773332
	#
	# Read up on ssl_ciphers to ensure a secure configuration.
	# See: https://bugs.debian.org/765782
	#
	# Self signed certs generated by the ssl-cert package
	# Don't use them in a production server!
	#
	# include snippets/snakeoil.conf;

	root /var/www/html;

	# Add index.php to the list if you are using PHP
	index index.html index.htm index.nginx-debian.html;

	server_name _;

	location / {
	        # First attempt to serve request as file, then
	        # as directory, then fall back to displaying a 404.
	        try_files $uri $uri/ =404;
	}

	# pass PHP scripts to FastCGI server
	#
	#location ~ \.php$ {
	#	include snippets/fastcgi-php.conf;
	#
	#	# With php-fpm (or other unix sockets):
	#	fastcgi_pass unix:/var/run/php/php7.0-fpm.sock;
	#	# With php-cgi (or other tcp sockets):
	#	fastcgi_pass 127.0.0.1:9000;
	#}

	# deny access to .htaccess files, if Apache's document root
	# concurs with nginx's one
	#
	#location ~ /\.ht {
	#	deny all;
	#}
}
Так, include в http добавит новый блок server, который определит информацию о новом виртуальном хосте, то есть о доменном имени.

Вернемся к последнему пункту основных правил, которые мы привели выше (у каждой директивы есть свой разрешенный контекст). Он подразумевает, что каждая директива может находиться лишь в конкретных подуровнях конфигурационного файла. Связано это с приязкой к фунциональности и гибкости конкретного модуля. Так, например, поскольку пользователь, от имени которого запускается nginx, может быть установлен только один раз, то его можно установить лишь в контексте main, в то время как директива error_log может быть установлена практически в любом контексте. Для того чтобы узнать, в каком контексте можно использовать конкретную директиву, нужно смотреть документацию модуля, отвечающего за эту директиву. Для примера приведем выдержку из документации модуля ngx_core_module для директивы user:

Syntax:	user user [group];
Default: user nobody nobody;
Context: main
и директивы error_log:

Syntax:	error_log file [level];
Default: error_log logs/error.log error;
Context: main, http, mail, stream, server, location
Но, как правило, чтобы узнать, из какого модуля конкретная директива, достаточно в поисковике просто ввести запрос nginx $DIRECTIVE и, с высокой долей вероятности, вы найдете информацию о нужной директиве в одном из первых результатов поиска.

log_format
Директива log_format позволяет описать, что будет содержаться в журнале запросов - какие поля и в какой очередности.

По умолчанию, nginx использует следующий формат логов (названный combined):

log_format combined '$remote_addr - $remote_user [$time_local] '
                    '"$request" $status $body_bytes_sent '
                    '"$http_referer" "$http_user_agent"';
По аналогии с bash, все, что начинается со спецсимвола $, - это переменные, большинство из которых доступно по умолчанию. Однако, как мы увидим далее, возможно задать новые переменные, которые также можно отдавать в логах, описав их новый формат.

access_log
Форматы логов используются в директиве access_log следующим образом - access_log ${LOG_PATH} ${LOG_FORMAT}. Пример использования - access_log /var/log/nginx/access.log combined.

Возможно в одной директиве использовать несколько access_log, чтобы писать в разные файлы с разными форматами. Это бывает полезно, когда нам нужны разные уровни детализации либо логи далее используются каким-то еще сервисом.

error_log
Кроме access log, существует еще один лог - error_log. Он используется для записи ошибок работы nginx. В отличие от директивы access_log, в error_log передается не формат логов, а минимальный уровень детализации. По умолчанию используется уровень error, но существуют и другие уровни, вплоть до debug. Пример использования - error_log /var/log/nginx/error.log debug.

server
Директива server определяет так называемый виртуальный хост, что позволяет на одном IP-адресе обрабатывать несколько доменов. С точки зрения внутренней логики, определение производится по HTTP заголовку Host, который выставляется, когда вы обращаетесь к конкретному серверу по DNS-имени. Каждый server может быть запущен на своем адресе и порту, либо обрабатывать конкретное (или несколько конкретных) DNS-имен. Кроме того, можно создать server, который привязан не к конкретному доменному имени, а только к порту. По умолчанию nginx устанавливается с конфигурационным файлом для такого обработчика. Далее рассмотрим директивы, которые отвечают за конфигурацию этих параметров сервера.

server_name
При помощи директивы server_name можно как раз указать, какие DNS-имена будет обрабатывать конкретный server. Так, к примеру, если мы хотим определить, чтобы сервер обрабатывал только домен example.com, то директива должна выглядеть просто как server_name example.com;.

Если же требуется обрабатывать несколько доменных имен, то они указываются друг за другом и разделяются пробелами, к примеру, server_name example.com www.example.com;.

Кроме этого, директива позволяет устанавливать wildcard правила, которые, к примеру, позволяют обрабатывать все субдомены - server_name example.com *.example.com;.

Отдельным случаем является использование пустого server_name ("") - он определяет, что запросы без Host (к примеру, по IP-адресу) будут обрабатываться этим server.

В случае, если необходимо потестировать работу конкретного server по server_name с локали, то есть возможность добавить соответствующую запись в /etc/hosts или при запросе через тот же curl установить заголовок Host при запросе.

listen
Данная директива позволяет определить, где слушает конкретный сервер - какой порт, какой IP-адрес или вообще Unix сокет. Кроме этого, он позволяет установить большое количество опций по работе сервера, например, используется ли SSL, по какому протоколу производится общение с сервером (к примеру, HTTP2 или HTTP1) и так далее.

Самый распространенный случай использования - это определение порта, на котором слушает сервер и частые опции - http2 и ssl. Такой кейс в виде директивы выглядит как listen 443 http2 ssl. Также популярен и, пусть и простой, но очень важный формат, который позволяет повесить сервер на конкретный порт без SSL - listen 8080. Эти два сценария использования данной директивы наиболее распространены и встречаются наиболее часто.

Кроме описанных выше, есть еще одна очень важная опция - default_server, которая определяет, что конкретно этот сервер будет использоваться по умолчанию для пары IP-адрес - порт. Представим, что у нас есть 3 server:

server_name ""; listen 80 default_server;
server_name example.com; listen 80;
server_name ""; listen 127.0.0.1:80 default_server;
Каждый из них имеет право жить и будет обрабатывать разные запросы.

location
Мы наконец подобрались к одной из основных директив для блока server, которая сама является блоком, - location. Она используется для определения логики по определенным путям и на нее завязана работа некоторых других директив.

Продублируем пример директивы из блока выше с примером server:

location / {
  try_files $uri $uri/ =404;
}
Как видите, внутри нее могут располагаться другие директивы, актуальные именно для этого пути. Далее начнем разбираться с подобными директивами.

root/alias
Теперь разберем то, как отдавать статический контент с вашего сервера. К счастью, nginx с этим справляется прекрасно и часто используется именно для отдачи статики, снимая эту нагрузку с сервисов, которые занимаются обработкой динамических запросов (но об это позднее).

Для этого существует 2 директивы - root и alias. Они схожи по функциональности, но работают немного по-разному, поэтому необходимо разбираться, как они действуют.

Начнем с root - данная директива определяет, какой путь выступает корнем пути. Относительно него определяется, к какому файлу обращаться при запросе. Представим, что у нас есть директория /var/www/static, в которой у нас есть изображения. В этом случае мы можем установить директиву root /var/www/static, и тогда при обращении к пути /image.png мы, по факту, обратимся к файлу /var/www/static/image.png.

При этом не важно, в каком location мы установим эту директиву, файл будет включать в поиск полный путь.

В случае же директивы alias мы создаем некую символическую ссылку, и обращение будет производиться к файлу без добавления location к пути.

Тут возникает важная разница между root и alias: первый - абсолютный, второй - относительный. Из-за этого появляется особенность работы со слешем в конце директивы. Приведем пример server и разберем запросы на примере:

server {
  listen 80;
  server_name example.com;

  location /a {
    root /www;
  }
  location /b {
    root /www/;
  }
  location /c {
    alias /www;
  }
  location /d {
    alias /www/;
  }
}
4 location здесь для того, чтобы показать влияние слеша в конце пути. Реальное же обращение по файлам будет следующее:

http://example.com/a/my/file -> /www/a/my/file
http://example.com/b/my/file -> /www/b/my/file
http://example.com/c/my/file -> /wwwmy/file # вряд ли мы этого хотели
http://example.com/d/my/file -> /www/my/file
В целом, документация рекомендует не использовать директиву root внутри location, а выносить ее в контекст server, но бывает, что без этого не обойтись.

На этом закончим наше первое знакомство с nginx, но продолжим еще в следущем задании, в котором разберем, как мы можем ограничить доступ к нашему серверу и использовать nginx в роли reverse proxy.

Полезные ссылки:
Usage statistics of web servers
nginx (archlinux wiki rus)
Основная функциональность (nginx docs)
Логи error_log и access_log в Nginx
Configuration file measurement units
Директива listen
Nginx alias vs root directives. Nginx serves static files. Trailing slash in path





************************************************************
Задание:
Это задание выполняется на виртуальной машине, которую Вы создаете самостоятельно на инфраструктуре Ребрейн. Необходимая информация и инструкции размещены на вкладке "Инфраструктура" (просьба строго соблюдать). Для создания/удаления виртуальной машины Вы можете использовать любой знакомый Вам инструмент (например, Terraform) или утилиту hcloud.
Пример использования hcloud:

hcloud ssh-key create --name <your_ssh_key_name> --label 'module=linux’ --label 'email=ii_at_rebrainme_com' --public-key-from-file string <path_to_pub_key>

hcloud server create --name <server_name> --type cpx11 --ssh-key <your_ssh_key_name> --label 'module=docker' --label 'email=ii_at_rebrainme_com' --image ubuntu-18.04
Установите пакет nginx-full.
Напишите конфигурационный файл nginx, который реализует следующую функциональность:
Отключен модуль mail.
В отдельном конфигурационном файле должен быть описан server, который слушает на 80 порту и использует домен, полученный при помощи сервиса http://nip.io/. Например, Ваш публичный адрес 100.101.102.103, тогда один из вариантов имени будет app.100.101.102.103.nip.io. Если этот сервис недоступен, то можно воспользоваться любым аналогичным.
Используется формат логов с именем logz, который содержит только информацию о том, откуда был произведен запрос, в какое время, какой был произведен запрос и какой HTTP код был возвращен при запросе.
Логи должны писаться в файл /var/log/nginx/nip.access.log.
В роли root используется /var/www/html/.
В роли index - /var/www/html/index.nginx-debian.html, которая должна возвращаться при обращении к /.
Путь /rbm_images/* должен отдавать файлы из /var/www/rebrain/images/, где должен быть расположен файл http://rebrainme.com/files/logo_rebrain_black.png под именем logo.png.
В ответе пришлите:
конфигурационный файл для основного сервера и путь до него;
список файлов в /etc/nginx/modules-enabled/.


*******************************************************************


Решение
*******************************************************************
Ефошкин Максим Вячеславович
ОТПРАВЛЕНО
02.06.2022 11:33
1. Создание ВМ
[m.efoshkin@MiWiFi-R4A-srv lnxa]$ yc compute instance create     --name efoshkin-lnxa-01-01     --network-interface subnet-name=default-ru-central1-b,nat-ip-version=ipv4     --zone ru-central1-b     --ssh-key ~/.ssh/id_rsa.pub     --cores 2     --core-fraction 5     --preemptible     --create-boot-disk image-folder-id=standard-images,image-family=ubuntu-2004-lts     --labels user_email=maxefoshkin@gmail.com,task_name=lnxa-01-01
done (22s)
id: epdr07go62no20vse38r
folder_id: b1gu2vqv4hil3okf70bb
created_at: "2022-06-02T07:00:09Z"
name: efoshkin-lnxa-01-01
labels:
  task_name: lnxa-01-01
  user_email: maxefoshkin@gmail.com
zone_id: ru-central1-b
platform_id: standard-v2
resources:
  memory: "2147483648"
  cores: "2"
  core_fraction: "5"
status: RUNNING
boot_disk:
  mode: READ_WRITE
  device_name: epdi4040si4ufm1lmekm
  auto_delete: true
  disk_id: epdi4040si4ufm1lmekm
network_interfaces:
- index: "0"
  mac_address: d0:0d:1b:01:e1:83
  subnet_id: e2lebfr9cjkjg4ruk3gn
  primary_v4_address:
    address: 10.129.0.42
    one_to_one_nat:
      address: 51.250.107.25
      ip_version: IPV4
fqdn: epdr07go62no20vse38r.auto.internal
scheduling_policy:
  preemptible: true
network_settings:
  type: STANDARD
placement_policy: {}


2. Установите пакет nginx-full.
yc-user@epddesppetsnroe63rb9:~$ sudo apt install nginx-full

3. Напишите конфигурационный файл nginx, который реализует следующую функциональность:
Всю конфигурацию я добавил в созданный мной файл nip.io :

root@epdmkq32us2av7bua7bs:/etc/nginx/sites-enabled# ll
total 8
drwxr-xr-x 2 root root 4096 Jun  1 07:09 ./
drwxr-xr-x 8 root root 4096 Jun  1 07:59 ../
lrwxrwxrwx 1 root root   25 Jun  1 07:09 nip.io -> ../sites-available/nip.io


root@epdr07go62no20vse38r:/var/www/rebrain/images# cat /etc/nginx/sites-available/nip 
log_format logz '$remote_addr [$time_local]'
                '"$request" $status';

server {
       listen 80 default_server;
       listen [::]:80 default_server;

       access_log /var/log/nginx/nip.access.log logz;

       server_name 51.250.107.25.nip.io;

       root /var/www/html;

#       index index.nginx-debian.html;

       location / {
		
  	      index index.nginx-debian.html;
              try_files  $uri $uri/ =404;
       }

       location /rbm_images/* {
      	      alias /var/www/rebrain/images/ ;
            #  try_files $uri $uri/ *;
	      autoindex on;

       }
}


 



root@epdmkq32us2av7bua7bs:/etc/nginx# cd modules-enabled/
root@epdmkq32us2av7bua7bs:/etc/nginx/modules-enabled# ll
total 24
drwxr-xr-x 2 root root 4096 Jun  1 06:33 ./
drwxr-xr-x 8 root root 4096 Jun  1 07:59 ../
lrwxrwxrwx 1 root root   57 Jun  1 06:33 50-mod-http-auth-pam.conf -> /usr/share/nginx/modules-available/mod-http-auth-pam.conf
lrwxrwxrwx 1 root root   56 Jun  1 06:33 50-mod-http-dav-ext.conf -> /usr/share/nginx/modules-available/mod-http-dav-ext.conf
lrwxrwxrwx 1 root root   53 Jun  1 06:33 50-mod-http-echo.conf -> /usr/share/nginx/modules-available/mod-http-echo.conf
lrwxrwxrwx 1 root root   55 Jun  1 06:33 50-mod-http-geoip2.conf -> /usr/share/nginx/modules-available/mod-http-geoip2.conf
lrwxrwxrwx 1 root root   54 Jun  1 06:33 50-mod-http-geoip.conf -> /usr/share/nginx/modules-available/mod-http-geoip.conf
lrwxrwxrwx 1 root root   61 Jun  1 06:33 50-mod-http-image-filter.conf -> /usr/share/nginx/modules-available/mod-http-image-filter.conf
lrwxrwxrwx 1 root root   60 Jun  1 06:33 50-mod-http-subs-filter.conf -> /usr/share/nginx/modules-available/mod-http-subs-filter.conf
lrwxrwxrwx 1 root root   62 Jun  1 06:33 50-mod-http-upstream-fair.conf -> /usr/share/nginx/modules-available/mod-http-upstream-fair.conf
lrwxrwxrwx 1 root root   60 Jun  1 06:33 50-mod-http-xslt-filter.conf -> /usr/share/nginx/modules-available/mod-http-xslt-filter.conf
lrwxrwxrwx 1 root root   48 Jun  1 06:33 50-mod-mail.conf -> /usr/share/nginx/modules-available/mod-mail.conf
lrwxrwxrwx 1 root root   50 Jun  1 06:33 50-mod-stream.conf -> /usr/share/nginx/modules-available/mod-stream.conf
root@epdmkq32us2av7bua7bs:/etc/nginx/modules-enabled# 


#Скачайный файл лого
root@epdr07go62no20vse38r:/var/www# mkdir -p rebrain/images
root@epdr07go62no20vse38r:/var/www# cd rebrain/images/
root@epdr07go62no20vse38r:/var/www/rebrain/images# wget http://rebrainme.com/files/logo_rebrain_black.png logo.png
--2022-06-02 07:08:04--  http://rebrainme.com/files/logo_rebrain_black.png
Resolving rebrainme.com (rebrainme.com)... 185.206.165.150
Connecting to rebrainme.com (rebrainme.com)|185.206.165.150|:80... connected.
HTTP request sent, awaiting response... 301 Moved Permanently
Location: https://rebrainme.com/files/logo_rebrain_black.png [following]
--2022-06-02 07:08:04--  https://rebrainme.com/files/logo_rebrain_black.png
Connecting to rebrainme.com (rebrainme.com)|185.206.165.150|:443... connected.
HTTP request sent, awaiting response... 200 OK
Length: 15581 (15K) [image/png]
Saving to: ‘logo_rebrain_black.png’

logo_rebrain_black.png              100%[=================================================================>]  15.22K  --.-KB/s    in 0s      

2022-06-02 07:08:04 (267 MB/s) - ‘logo_rebrain_black.png’ saved [15581/15581]

--2022-06-02 07:08:04--  http://logo.png/
Resolving logo.png (logo.png)... failed: Name or service not known.
wget: unable to resolve host address ‘logo.png’
FINISHED --2022-06-02 07:08:04--
Total wall clock time: 0.04s
Downloaded: 1 files, 15K in 0s (267 MB/s)
root@epdr07go62no20vse38r:/var/www/rebrain/images# mv logo_rebrain_black.png logo.png

РАботает.


