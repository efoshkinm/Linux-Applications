Задание:
Настройте автоматическое монтирование nfs директории /rebrainme с сервера 192.168.1.4 в /mnt.

Приведите пример конфигурации NFS сервера, который:

Позволяет примонтировать директорию /rebrainme для адресов 192.168.1.4, 192.168.1.5, 192.168.1.6 и 192.168.1.7 на запись.


****************************************************************************
Решение
****************************************************************************

Ефошкин Максим Вячеславович
ОТПРАВЛЕНО
23.11.2022 20:48
1. Настройте автоматическое монтирование nfs директории /rebrainme с сервера 192.168.1.4 в /mnt.
Поднял 4 машины 192.168.1.4-7
Устанавливаю nfs сервер на 192.168.1.4, как указано в пункте 1 .
sudo apt-get install nfs-kernel-server nfs-common
mkdir /rebrainme
cat /etc/exports
/rebrainme 192.168.1.5/24(rw,sync,insecure,nohide,no_root_squash,no_subtree_check)

И так как не указано на какой сервер монтировать nfs шару, то я выберу монтировать на 5 сервер.
Для этого установим autofs хотя можно сделать через fstab, fstab я настраивал в линукс бейсик, а автофс нет.
sudo apt-get install autofs
mkdir /mnt/rebrainme

vi /etc/auto.master
/mnt /etc/auto.mnt  --timeout=60

vi /etc/auto.nfs
rebrainme  -rw -fstype=nfs4 192.168.1.4:/rebrainme

systemctl start autofs
нужно перейти по пути чтобы nfs подцепил шару 
cd /mnt/rebrainme
2. Приведите пример конфигурации NFS сервера, который: 1)Позволяет примонтировать директорию /rebrainme для адресов 192.168.1.4, 192.168.1.5, 192.168.1.6 и 192.168.1.7 на запись.
 cat /etc/exports
/rebrainme 192.168.1.4/24(rw,sync,insecure,nohide,no_root_squash,no_subtree_check)
/rebrainme 192.168.1.5/24(rw,sync,insecure,nohide,no_root_squash,no_subtree_check)
/rebrainme 192.168.1.6/24(rw,sync,insecure,nohide,no_root_squash,no_subtree_check)
/rebrainme 192.168.1.7/24(rw,sync,insecure,nohide,no_root_squash,no_subtree_check)
 
 
ОТВЕТ КУРАТОРА
Алексей Кузнецов (@Hystrix)
ВЫПОЛНЕНО 5
24.11.2022 09:23
Добрый день!

Все верно, иногда монтирование внешних файловых систем выносят в юниты Systemd, чтобы прописать зависимости служб от монтирования системы. Если не найдете в привичных местах, то стоит поискать в юнитах.

Отличные знание темы и выполнение задания, замечаний и вопросов нет!


*****************************************************************************
Теория
*****************************************************************************


LNXA-09 02: Storage. NFS
Описание:
Сетевой протокол NFS (Network File System) позволяет предоставить пользователям совместный доступ к файлам, расположенным на разных компьютерах.

Первая открытая версия протокола появилась в 1989 году с номером 2 (до этого существовала первая версия, которая применялась в экспериментальных целях в компании Sun). Основным недостатком второй версии являлось то, что клиент мог считать запись успешной только после ответа сервера. Это ограничение существенно замедляло запись, так как сервер должен был записывать каждый блок на диск перед ответом клиенту.

В третьей версии протокола устранили этот недостаток за счет добавления асинхронной записи. Также были допилены другие характеристики протокола для работы с большими файлами. И появилась поддержка TCP, что позволило NFS работать в глобальных сетях.

NFS 4 вышла в 2000 году и является актуальной версией. В ней протокол был существенно переработан. Прежде чем перечислить нововведения версии, немного отвлечемся на другой вопрос. Дело в том, что при разработке файловых систем нужно определиться с тем, сохраняет ли сервер состояние (state) открываемых каждым клиентом файлов. Если нет — он называется сервером без сохранения состояния (stateless). А если сохраняет — это соответственно сервер с сохранением состояния (stateful). Оба подхода имеют как преимущества, так и недостатки.

В stateless подходе каждый запрос не зависит от предыдущего, поэтому если клиент или сервер упали, то это не приводит к проблемам. Однако сервер не может знать, какие клиенты с какими файлами работают и что затрудняет параллельную работу.
В stateful подходе сервер отслеживает все открытые файлы, что позволяет настроить параллельную работу. Но этот подход затрудняет работу после падения клиента или сервера, так как они должны договориться, какое состояние стоит считать последним перед падением.
А теперь рассмотрим нововведения NFS 4:

улучшения производительности;
улучшение безопасности;
возможность операций с сохранением состояния;
поддержка клиентов как Unix, так и Windows;
ACL;
поддержка файлов в Unicode;
интегрирование в основном протоколе NFS протоколов блокировки и монтирования;
Parallel NFS.
Прежде чем перейти к практике, стоит рассмотреть, как различные версии NFS экспортируют файловые системы и используют блокировку файлов.

Во 2 и 3 версиях экспорт каждого каталога — независимая сущность. Из-за этого каждый монтируемый каталог тоже является независимой сущностью, а значит, клиенты должны выполнять несколько разных запросов на монтирование. В четвертой версии каждый сервер экспортирует одну псевдофайловую систему, в которой содержатся все экспортируемые каталоги. Рассмотрим пример экспортирования трех каталогов (они заканчиваются на _nfs):

/var/log/rebrainme1_nfs
/var/log/rebrainme2_nfs
/var/log/rebrainme3
/var/tmp/rebrainme_nfs
Как уже было сказано, в NFS 2 и NFS 3 каждый из каталогов (/var/log/rebrainme1_nfs, /var/log/rebrainme2_nfs и /var/tmp/rebrainme_nfs) должен конфигурироваться отдельно. А в NFS 4 будет отдельная псевдофайловая система, имеющая вид:

/
    /var
        /log
            /rebrainme1_nfs
            /rebrainme2_nfs
        /tmp
            /rebrainme_nfs
Директория /var/log/rebrainme3 не появляется в иерархии, так как она не подлежит экспорту. Отдельные каталоги, которые не подлежат экспорту, также не появятся в иерархии.

Механизм блокировок для версий 2 и 3 реализован отдельно от протокола NFS с помощью демонов lockd (менеджер блокировок сети NLM - Network Lock Manager) и statd (монитор состояния сети NSM - Network Status Monitor). В четвертой версии эти демоны не используются, так как сервер сохраняет состояние файлов. Даже если вы используете NFS 4, вы все равно можете увидеть запущенные демоны lockd и statd, потому что они нужны для поддержки предыдущих версий.

Рассмотрим базовую настройку сервера и клиента. В первую очередь нужно установить требуемые пакеты (общие для клиента и сервера):

nfs-kernel-server nfs-common
Далее нужно добавить экспортируемые файловые системы в файл /etc/exports, который имеет следующий формат:

экспортируемая_система клиент(параметры)
Экспортируемая система — путь к директории, к которой выдается доступ.
Клиент — IP-адрес клиента, которому выдается доступ (можно использовать маски подсетей). Также можно использовать имена доменов с шаблонами в виде *.
Параметры — параметры экспорта:

ro — экспорт только для чтения.
rw — экспорт для чтения и записи.
root_squash — пользователь root на клиентской машине не будет иметь доступа к разделяемой директории сервера.
no_root_squash — противоположен root_squash.
all_squash — отображает все идентификаторы UID и GID в значения, установленные для анонимных пользователей. Целесообразно для персональных компьютеров и отдельных узлов, не вызывающих доверия.
anonuid= — задает идентификатор UID для удаленных привилегированных пользователей, которых следует лишить привилегий.
anongid= — задает идентификатор GID для удаленных привилегированных пользователей, которых следует лишить привилегий.
secure — допускает удаленный доступ только через привилегированный порт.
insecure — допускает удаленный доступ через любой порт.
noaccess — блокирует доступ к данному каталогу и подкаталогам (используется при вложенном экспорте).
wdelay — откладывает запись в ожидании объединенных обновлений.
no_wdelay — немедленно записывает данные на диск.
async — заставляет сервер отвечать на запросы до того, как запись на диск будет выполнена в действительности.
nohide — выявляет файловые системы, смонтированные в дереве экспортированных файлов.
hide — противоположен по смыслу параметру nohide.
subtree_check — проверяет, находится ли запрашиваемый файл в экспортированном дереве.
no_subtree_check — проверяет, относится ли запрашиваемый файл к экспортированной файловой системе.
secure_locks — требует авторизации для всех запросов на блокировку.
insecure_locks — использует менее строгие критерии блокировки (поддерживает старых клиентов).
fsid-num — задает псевдофайловую систему в версии 4 (обычно 0).
Ниже приведен пример настройки для директории /var/nfs:

192.168.44.4# tail -n1 /etc/exports
/var/nfs 192.168.44.2(rw,async,no_subtree_check)
После настройки и перезапуска сервера примонтируем директорию на клиенте:

192.168.44.2# mount -t nfs4 -O uid=1000,iocharset=utf-8 192.168.44.4:/var/nfs /mnt/nfs
192.168.44.2# ls -l /mnt/nfs/
total 0
192.168.44.2# echo NFS > /mnt/nfs/rebrainme-client
192.168.44.4# echo NFS > /var/nfs/rebrainme-server
192.168.44.2# ls -l /mnt/nfs/
total 8
-rw-r--r-- 1 nobody nogroup 4 Nov  7 19:32 rebrainme-client
-rw-r--r-- 1 root   root    4 Nov  7 19:33 rebrainme-server

192.168.44.2# df -h /mnt/nfs/
Filesystem              Size  Used Avail Use% Mounted on
192.168.44.4:/var/nfs   37G   16G   20G  45% /mnt/nfs
В результате удалось получить файловую систему на клиенте с доступом к данным на сервере.

Некоторые полезные команды и советы для работы с NFS:

showmount -e $IP - показывает, какие файловые системы предоставляет сервер IP.
exportfs -v демонстрирует существующие экспортированные файловые системы на сервере.
Файловую систему можно примонтировать при начальной загрузке системы через /etc/fstab.
С помощью команды nfsstat [-s|-c] можно посмотреть статистику для сервера и клиента.
Полезные ссылки:
Network File System (NFS) version 4 Protocol
NFS|Русскоязычная документация по Ubuntu
